(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactBootstrapTable2"] = factory(require("react"));
	else
		root["ReactBootstrapTable2"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(10)();
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  SORT_ASC: 'asc',
  SORT_DESC: 'desc',
  ROW_SELECT_SINGLE: 'radio',
  ROW_SELECT_MULTIPLE: 'checkbox',
  ROW_SELECT_DISABLED: 'ROW_SELECT_DISABLED',
  CHECKBOX_STATUS_CHECKED: 'checked',
  CHECKBOX_STATUS_INDETERMINATE: 'indeterminate',
  CHECKBOX_STATUS_UNCHECKED: 'unchecked'
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* eslint no-empty: 0 */
/* eslint no-param-reassign: 0 */
/* eslint prefer-rest-params: 0 */

function splitNested(str) {
  return [str].join('.').replace(/\[/g, '.').replace(/\]/g, '').split('.');
}

function get(target, field) {
  var pathArray = splitNested(field);
  var result = void 0;
  try {
    result = pathArray.reduce(function (curr, path) {
      return curr[path];
    }, target);
  } catch (e) {}
  return result;
}

function set(target, field, value) {
  var safe = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var pathArray = splitNested(field);
  var level = 0;
  pathArray.reduce(function (a, b) {
    level += 1;
    if (typeof a[b] === 'undefined') {
      if (!safe) throw new Error(a + '.' + b + ' is undefined');
      a[b] = {};
      return a[b];
    }

    if (level === pathArray.length) {
      a[b] = value;
      return value;
    }
    return a[b];
  }, target);
}

function isFunction(obj) {
  return obj && typeof obj === 'function';
}

/**
 * Checks if `value` is the Object. the `Object` except `Function` and `Array.`
 *
 * @param {*} obj - The value gonna check
 */
function isObject(obj) {
  var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  return obj !== null && type === 'object' && obj.constructor === Object;
}

function isEmptyObject(obj) {
  if (!isObject(obj)) return false;

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i += 1) {
    if (hasOwnProperty.call(obj, keys[i])) return false;
  }

  return true;
}

function isDefined(value) {
  return typeof value !== 'undefined' && value !== null;
}

function sleep(fn, ms) {
  return setTimeout(function () {
    return fn();
  }, ms);
}

function debounce(func, wait, immediate) {
  var _this = this,
      _arguments = arguments;

  var timeout = void 0;

  return function () {
    var later = function later() {
      timeout = null;

      if (!immediate) {
        func.apply(_this, _arguments);
      }
    };

    var callNow = immediate && !timeout;

    clearTimeout(timeout);
    timeout = setTimeout(later, wait || 0);

    if (callNow) {
      func.appy(_this, _arguments);
    }
  };
}

exports.default = {
  get: get,
  set: set,
  isFunction: isFunction,
  isObject: isObject,
  isEmptyObject: isEmptyObject,
  isDefined: isDefined,
  sleep: sleep,
  debounce: debounce
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var matchRow = exports.matchRow = function matchRow(keyField, id) {
  return function (row) {
    return row[keyField] === id;
  };
};

var getRowByRowId = exports.getRowByRowId = function getRowByRowId(_ref) {
  var data = _ref.data,
      keyField = _ref.keyField;
  return function (id) {
    return data.find(matchRow(keyField, id));
  };
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelectedRows = exports.unSelectableKeys = exports.selectableKeys = exports.isAnySelectedRow = exports.isSelectedAll = undefined;

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _rows = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isSelectedAll = exports.isSelectedAll = function isSelectedAll(_ref) {
  var data = _ref.data,
      selected = _ref.selected;
  return data.length === selected.length;
};

var isAnySelectedRow = exports.isAnySelectedRow = function isAnySelectedRow(_ref2) {
  var selected = _ref2.selected;
  return function () {
    var skips = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (skips.length === 0) {
      return selected.length > 0;
    }
    return selected.filter(function (x) {
      return !skips.includes(x);
    }).length;
  };
};

var selectableKeys = exports.selectableKeys = function selectableKeys(_ref3) {
  var data = _ref3.data,
      keyField = _ref3.keyField;
  return function () {
    var skips = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (skips.length === 0) {
      return data.map(function (row) {
        return _utils2.default.get(row, keyField);
      });
    }
    return data.filter(function (row) {
      return !skips.includes(_utils2.default.get(row, keyField));
    }).map(function (row) {
      return _utils2.default.get(row, keyField);
    });
  };
};

var unSelectableKeys = exports.unSelectableKeys = function unSelectableKeys(_ref4) {
  var selected = _ref4.selected;
  return function () {
    var skips = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (skips.length === 0) {
      return [];
    }
    return selected.filter(function (x) {
      return skips.includes(x);
    });
  };
};

var getSelectedRows = exports.getSelectedRows = function getSelectedRows(store) {
  var getRow = (0, _rows.getRowByRowId)(store);
  return store.selected.map(function (k) {
    return getRow(k);
  });
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(RemoteResolver, _ExtendBase);

    function RemoteResolver() {
      _classCallCheck(this, RemoteResolver);

      return _possibleConstructorReturn(this, (RemoteResolver.__proto__ || Object.getPrototypeOf(RemoteResolver)).apply(this, arguments));
    }

    _createClass(RemoteResolver, [{
      key: 'getNewestState',
      value: function getNewestState() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var store = this.store || this.props.store;
        return _extends({
          page: store.page,
          sizePerPage: store.sizePerPage,
          filters: store.filters,
          sortField: store.sortField,
          sortOrder: store.sortOrder,
          data: store.getAllData()
        }, state);
      }
    }, {
      key: 'isRemotePagination',
      value: function isRemotePagination() {
        var remote = this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.pagination;
      }
    }, {
      key: 'isRemoteFiltering',
      value: function isRemoteFiltering() {
        var remote = this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.filter;
      }
    }, {
      key: 'isRemoteSort',
      value: function isRemoteSort() {
        var remote = this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.sort;
      }
    }, {
      key: 'isRemoteCellEdit',
      value: function isRemoteCellEdit() {
        var remote = this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.cellEdit;
      }
    }, {
      key: 'handleRemotePageChange',
      value: function handleRemotePageChange() {
        this.props.onTableChange('pagination', this.getNewestState());
      }
    }, {
      key: 'handleRemoteFilterChange',
      value: function handleRemoteFilterChange() {
        var newState = {};
        if (this.isRemotePagination()) {
          var options = this.props.pagination.options || {};
          newState.page = _utils2.default.isDefined(options.pageStartIndex) ? options.pageStartIndex : 1;
        }
        this.props.onTableChange('filter', this.getNewestState(newState));
      }
    }, {
      key: 'handleSortChange',
      value: function handleSortChange() {
        this.props.onTableChange('sort', this.getNewestState());
      }
    }, {
      key: 'handleCellChange',
      value: function handleCellChange(rowId, dataField, newValue) {
        var cellEdit = { rowId: rowId, dataField: dataField, newValue: newValue };
        this.props.onTableChange('cellEdit', this.getNewestState({ cellEdit: cellEdit }));
      }
    }]);

    return RemoteResolver;
  }(ExtendBase);
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bootstrapTable = __webpack_require__(9);

var _bootstrapTable2 = _interopRequireDefault(_bootstrapTable);

var _container = __webpack_require__(28);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _container2.default)(_bootstrapTable2.default);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _header = __webpack_require__(14);

var _header2 = _interopRequireDefault(_header);

var _caption = __webpack_require__(19);

var _caption2 = _interopRequireDefault(_caption);

var _body = __webpack_require__(20);

var _body2 = _interopRequireDefault(_body);

var _propsResolver = __webpack_require__(26);

var _propsResolver2 = _interopRequireDefault(_propsResolver);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _selection = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint arrow-body-style: 0 */

var BootstrapTable = function (_PropsBaseResolver) {
  _inherits(BootstrapTable, _PropsBaseResolver);

  function BootstrapTable(props) {
    _classCallCheck(this, BootstrapTable);

    var _this = _possibleConstructorReturn(this, (BootstrapTable.__proto__ || Object.getPrototypeOf(BootstrapTable)).call(this, props));

    _this.validateProps();

    _this.state = {
      data: props.data
    };
    return _this;
  }

  _createClass(BootstrapTable, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.setState({
        data: nextProps.data
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          loading = _props.loading,
          overlay = _props.overlay;

      var table = this.renderTable();
      if (loading && overlay) {
        var LoadingOverlay = overlay(table, loading);
        return _react2.default.createElement(LoadingOverlay, null);
      }
      return table;
    }
  }, {
    key: 'renderTable',
    value: function renderTable() {
      var _props2 = this.props,
          store = _props2.store,
          columns = _props2.columns,
          keyField = _props2.keyField,
          id = _props2.id,
          classes = _props2.classes,
          striped = _props2.striped,
          hover = _props2.hover,
          bordered = _props2.bordered,
          condensed = _props2.condensed,
          noDataIndication = _props2.noDataIndication,
          caption = _props2.caption,
          rowStyle = _props2.rowStyle,
          rowClasses = _props2.rowClasses,
          rowEvents = _props2.rowEvents;


      var tableClass = (0, _classnames2.default)('table', {
        'table-striped': striped,
        'table-hover': hover,
        'table-bordered': bordered,
        'table-condensed': condensed
      }, classes);

      var cellSelectionInfo = this.resolveSelectRowProps({
        onRowSelect: this.props.onRowSelect
      });

      var headerCellSelectionInfo = this.resolveSelectRowPropsForHeader({
        onAllRowsSelect: this.props.onAllRowsSelect,
        selected: store.selected,
        allRowsSelected: (0, _selection.isSelectedAll)(store)
      });

      var tableCaption = caption && _react2.default.createElement(
        _caption2.default,
        null,
        caption
      );

      return _react2.default.createElement(
        'div',
        { className: 'react-bootstrap-table' },
        _react2.default.createElement(
          'table',
          { id: id, className: tableClass },
          tableCaption,
          _react2.default.createElement(_header2.default, {
            columns: columns,
            sortField: store.sortField,
            sortOrder: store.sortOrder,
            onSort: this.props.onSort,
            onFilter: this.props.onFilter,
            selectRow: headerCellSelectionInfo
          }),
          _react2.default.createElement(_body2.default, {
            data: this.state.data,
            keyField: keyField,
            columns: columns,
            isEmpty: this.isEmpty(),
            visibleColumnSize: this.visibleColumnSize(),
            noDataIndication: noDataIndication,
            cellEdit: this.props.cellEdit || {},
            selectRow: cellSelectionInfo,
            selectedRowKeys: store.selected,
            rowStyle: rowStyle,
            rowClasses: rowClasses,
            rowEvents: rowEvents
          })
        )
      );
    }
  }]);

  return BootstrapTable;
}((0, _propsResolver2.default)(_react.Component));

BootstrapTable.propTypes = {
  keyField: _propTypes2.default.string.isRequired,
  data: _propTypes2.default.array.isRequired,
  columns: _propTypes2.default.array.isRequired,
  remote: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.shape({
    pagination: _propTypes2.default.bool
  })]),
  store: _propTypes2.default.object,
  noDataIndication: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
  striped: _propTypes2.default.bool,
  bordered: _propTypes2.default.bool,
  hover: _propTypes2.default.bool,
  id: _propTypes2.default.string,
  classes: _propTypes2.default.string,
  condensed: _propTypes2.default.bool,
  caption: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string]),
  pagination: _propTypes2.default.object,
  filter: _propTypes2.default.object,
  cellEdit: _propTypes2.default.object,
  selectRow: _propTypes2.default.shape({
    mode: _propTypes2.default.oneOf([_const2.default.ROW_SELECT_SINGLE, _const2.default.ROW_SELECT_MULTIPLE]).isRequired,
    clickToSelect: _propTypes2.default.bool,
    clickToEdit: _propTypes2.default.bool,
    onSelect: _propTypes2.default.func,
    onSelectAll: _propTypes2.default.func,
    style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    classes: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    nonSelectable: _propTypes2.default.array,
    bgColor: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    hideSelectColumn: _propTypes2.default.bool
  }),
  onRowSelect: _propTypes2.default.func,
  onAllRowsSelect: _propTypes2.default.func,
  rowStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
  rowEvents: _propTypes2.default.object,
  rowClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
  defaultSorted: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    dataField: _propTypes2.default.string.isRequired,
    order: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC]).isRequired
  })),
  defaultSortDirection: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC]),
  overlay: _propTypes2.default.func,
  onTableChange: _propTypes2.default.func,
  onSort: _propTypes2.default.func,
  onFilter: _propTypes2.default.func
};

BootstrapTable.defaultProps = {
  remote: false,
  striped: false,
  bordered: true,
  hover: false,
  condensed: false,
  noDataIndication: null
};

exports.default = BootstrapTable;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(11);
var invariant = __webpack_require__(12);
var ReactPropTypesSecret = __webpack_require__(13);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _headerCell = __webpack_require__(15);

var _headerCell2 = _interopRequireDefault(_headerCell);

var _selectionHeaderCell = __webpack_require__(18);

var _selectionHeaderCell2 = _interopRequireDefault(_selectionHeaderCell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Header = function Header(props) {
  var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED;
  var columns = props.columns,
      onSort = props.onSort,
      onFilter = props.onFilter,
      sortField = props.sortField,
      sortOrder = props.sortOrder,
      selectRow = props.selectRow;


  return _react2.default.createElement(
    'thead',
    null,
    _react2.default.createElement(
      'tr',
      null,
      selectRow.mode !== ROW_SELECT_DISABLED && !selectRow.hideSelectColumn ? _react2.default.createElement(_selectionHeaderCell2.default, selectRow) : null,
      columns.map(function (column, i) {
        if (!column.hidden) {
          var currSort = column.dataField === sortField;
          var isLastSorting = column.dataField === sortField;

          return _react2.default.createElement(_headerCell2.default, {
            index: i,
            key: column.dataField,
            column: column,
            onSort: onSort,
            sorting: currSort,
            onFilter: onFilter,
            sortOrder: sortOrder,
            isLastSorting: isLastSorting
          });
        }
        return false;
      })
    )
  );
}; /* eslint react/require-default-props: 0 */


Header.propTypes = {
  columns: _propTypes2.default.array.isRequired,
  onSort: _propTypes2.default.func,
  onFilter: _propTypes2.default.func,
  sortField: _propTypes2.default.string,
  sortOrder: _propTypes2.default.string,
  selectRow: _propTypes2.default.object
};

exports.default = Header;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint react/require-default-props: 0 */


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _symbol = __webpack_require__(16);

var _symbol2 = _interopRequireDefault(_symbol);

var _caret = __webpack_require__(17);

var _caret2 = _interopRequireDefault(_caret);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HeaderCell = function HeaderCell(props) {
  var column = props.column,
      index = props.index,
      onSort = props.onSort,
      sorting = props.sorting,
      sortOrder = props.sortOrder,
      isLastSorting = props.isLastSorting,
      onFilter = props.onFilter;
  var text = column.text,
      sort = column.sort,
      filter = column.filter,
      headerTitle = column.headerTitle,
      headerAlign = column.headerAlign,
      headerFormatter = column.headerFormatter,
      headerEvents = column.headerEvents,
      headerClasses = column.headerClasses,
      headerStyle = column.headerStyle,
      headerAttrs = column.headerAttrs,
      headerSortingClasses = column.headerSortingClasses,
      headerSortingStyle = column.headerSortingStyle;


  var cellAttrs = _extends({}, _utils2.default.isFunction(headerAttrs) ? headerAttrs(column, index) : headerAttrs, headerEvents);

  var sortSymbol = void 0;
  var filterElm = void 0;
  var cellStyle = {};
  var cellClasses = _utils2.default.isFunction(headerClasses) ? headerClasses(column, index) : headerClasses;

  if (headerStyle) {
    cellStyle = _utils2.default.isFunction(headerStyle) ? headerStyle(column, index) : headerStyle;
  }

  if (headerTitle) {
    cellAttrs.title = _utils2.default.isFunction(headerTitle) ? headerTitle(column, index) : text;
  }

  if (headerAlign) {
    cellStyle.textAlign = _utils2.default.isFunction(headerAlign) ? headerAlign(column, index) : headerAlign;
  }

  if (sort) {
    var customClick = cellAttrs.onClick;
    cellAttrs.onClick = function (e) {
      onSort(column);
      if (_utils2.default.isFunction(customClick)) customClick(e);
    };
    cellAttrs.className = (0, _classnames2.default)(cellAttrs.className, 'sortable');

    if (sorting) {
      sortSymbol = _react2.default.createElement(_caret2.default, { order: sortOrder });

      // append customized classes or style if table was sorting based on the current column.
      cellClasses = (0, _classnames2.default)(cellClasses, _utils2.default.isFunction(headerSortingClasses) ? headerSortingClasses(column, sortOrder, isLastSorting, index) : headerSortingClasses);

      cellStyle = _extends({}, cellStyle, _utils2.default.isFunction(headerSortingStyle) ? headerSortingStyle(column, sortOrder, isLastSorting, index) : headerSortingStyle);
    } else {
      sortSymbol = _react2.default.createElement(_symbol2.default, null);
    }
  }

  if (cellClasses) cellAttrs.className = (0, _classnames2.default)(cellAttrs.className, cellClasses);
  if (!_utils2.default.isEmptyObject(cellStyle)) cellAttrs.style = cellStyle;
  if (filter) {
    filterElm = _react2.default.createElement(filter.Filter, _extends({}, filter.props, { onFilter: onFilter, column: column }));
  }

  var children = headerFormatter ? headerFormatter(column, index, { sortElement: sortSymbol, filterElement: filterElm }) : text;

  if (headerFormatter) {
    return _react2.default.createElement('th', cellAttrs, children);
  }

  return _react2.default.createElement('th', cellAttrs, children, sortSymbol, filterElm);
};

HeaderCell.propTypes = {
  column: _propTypes2.default.shape({
    dataField: _propTypes2.default.string.isRequired,
    text: _propTypes2.default.string.isRequired,
    hidden: _propTypes2.default.bool,
    headerFormatter: _propTypes2.default.func,
    formatter: _propTypes2.default.func,
    formatExtraData: _propTypes2.default.any,
    headerClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    classes: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    headerStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    headerTitle: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    title: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    headerEvents: _propTypes2.default.object,
    events: _propTypes2.default.object,
    headerAlign: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    align: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    headerAttrs: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    attrs: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    sort: _propTypes2.default.bool,
    sortFunc: _propTypes2.default.func,
    onSort: _propTypes2.default.func,
    editable: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    editCellStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    editCellClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    editorStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    editorClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    validator: _propTypes2.default.func,
    filter: _propTypes2.default.object,
    filterValue: _propTypes2.default.func
  }).isRequired,
  index: _propTypes2.default.number.isRequired,
  onSort: _propTypes2.default.func,
  sorting: _propTypes2.default.bool,
  sortOrder: _propTypes2.default.oneOf([_const2.default.SORT_ASC, _const2.default.SORT_DESC]),
  isLastSorting: _propTypes2.default.bool,
  onFilter: _propTypes2.default.func
};

exports.default = HeaderCell;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SortSymbol = function SortSymbol() {
  return _react2.default.createElement(
    "span",
    { className: "order" },
    _react2.default.createElement(
      "span",
      { className: "dropdown" },
      _react2.default.createElement("span", { className: "caret" })
    ),
    _react2.default.createElement(
      "span",
      { className: "dropup" },
      _react2.default.createElement("span", { className: "caret" })
    )
  );
};

exports.default = SortSymbol;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SortCaret = function SortCaret(_ref) {
  var order = _ref.order;

  var orderClass = (0, _classnames2.default)('react-bootstrap-table-sort-order', {
    dropup: order === _const2.default.SORT_ASC
  });
  return _react2.default.createElement(
    'span',
    { className: orderClass },
    _react2.default.createElement('span', { className: 'caret' })
  );
};

SortCaret.propTypes = {
  order: _propTypes2.default.oneOf([_const2.default.SORT_ASC, _const2.default.SORT_DESC]).isRequired
};
exports.default = SortCaret;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CheckBox = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */


var CheckBox = exports.CheckBox = function CheckBox(_ref) {
  var checked = _ref.checked,
      indeterminate = _ref.indeterminate;
  return _react2.default.createElement('input', {
    type: 'checkbox',
    checked: checked,
    ref: function ref(input) {
      if (input) input.indeterminate = indeterminate; // eslint-disable-line no-param-reassign
    }
  });
};

CheckBox.propTypes = {
  checked: _propTypes2.default.bool.isRequired,
  indeterminate: _propTypes2.default.bool.isRequired
};

var SelectionHeaderCell = function (_Component) {
  _inherits(SelectionHeaderCell, _Component);

  function SelectionHeaderCell() {
    _classCallCheck(this, SelectionHeaderCell);

    var _this = _possibleConstructorReturn(this, (SelectionHeaderCell.__proto__ || Object.getPrototypeOf(SelectionHeaderCell)).call(this));

    _this.handleCheckBoxClick = _this.handleCheckBoxClick.bind(_this);
    return _this;
  }

  /**
   * avoid updating if button is
   * 1. radio
   * 2. status was not changed.
   */


  _createClass(SelectionHeaderCell, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      var ROW_SELECT_SINGLE = _const2.default.ROW_SELECT_SINGLE;
      var _props = this.props,
          mode = _props.mode,
          checkedStatus = _props.checkedStatus;


      if (mode === ROW_SELECT_SINGLE) return false;

      return nextProps.checkedStatus !== checkedStatus;
    }
  }, {
    key: 'handleCheckBoxClick',
    value: function handleCheckBoxClick(e) {
      var onAllRowsSelect = this.props.onAllRowsSelect;


      onAllRowsSelect(e);
    }
  }, {
    key: 'render',
    value: function render() {
      var CHECKBOX_STATUS_CHECKED = _const2.default.CHECKBOX_STATUS_CHECKED,
          CHECKBOX_STATUS_INDETERMINATE = _const2.default.CHECKBOX_STATUS_INDETERMINATE,
          ROW_SELECT_SINGLE = _const2.default.ROW_SELECT_SINGLE;
      var _props2 = this.props,
          mode = _props2.mode,
          checkedStatus = _props2.checkedStatus;


      var checked = checkedStatus === CHECKBOX_STATUS_CHECKED;

      var indeterminate = checkedStatus === CHECKBOX_STATUS_INDETERMINATE;

      return mode === ROW_SELECT_SINGLE ? _react2.default.createElement('th', { 'data-row-selection': true }) : _react2.default.createElement(
        'th',
        { 'data-row-selection': true, onClick: this.handleCheckBoxClick },
        _react2.default.createElement(CheckBox, _extends({}, this.props, {
          checked: checked,
          indeterminate: indeterminate
        }))
      );
    }
  }]);

  return SelectionHeaderCell;
}(_react.Component);

SelectionHeaderCell.propTypes = {
  mode: _propTypes2.default.string.isRequired,
  checkedStatus: _propTypes2.default.string,
  onAllRowsSelect: _propTypes2.default.func
};
exports.default = SelectionHeaderCell;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint react/require-default-props: 0 */
var Caption = function Caption(props) {
  if (!props.children) return null;
  return _react2.default.createElement(
    'caption',
    null,
    props.children
  );
};

Caption.propTypes = {
  children: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string])
};

exports.default = Caption;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint react/prop-types: 0 */
/* eslint react/require-default-props: 0 */

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _row = __webpack_require__(21);

var _row2 = _interopRequireDefault(_row);

var _rowSection = __webpack_require__(25);

var _rowSection2 = _interopRequireDefault(_rowSection);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Body = function Body(props) {
  var columns = props.columns,
      data = props.data,
      keyField = props.keyField,
      isEmpty = props.isEmpty,
      noDataIndication = props.noDataIndication,
      visibleColumnSize = props.visibleColumnSize,
      cellEdit = props.cellEdit,
      selectRow = props.selectRow,
      selectedRowKeys = props.selectedRowKeys,
      rowStyle = props.rowStyle,
      rowClasses = props.rowClasses,
      rowEvents = props.rowEvents;
  var bgColor = selectRow.bgColor,
      nonSelectable = selectRow.nonSelectable;


  var content = void 0;

  if (isEmpty) {
    var indication = _utils2.default.isFunction(noDataIndication) ? noDataIndication() : noDataIndication;
    if (!indication) {
      return null;
    }
    content = _react2.default.createElement(_rowSection2.default, { content: indication, colSpan: visibleColumnSize });
  } else {
    var nonEditableRows = cellEdit.nonEditableRows || [];
    content = data.map(function (row, index) {
      var key = _utils2.default.get(row, keyField);
      var editable = !(nonEditableRows.length > 0 && nonEditableRows.indexOf(key) > -1);

      var selected = selectRow.mode !== _const2.default.ROW_SELECT_DISABLED ? selectedRowKeys.includes(key) : null;

      var attrs = rowEvents || {};
      var style = _utils2.default.isFunction(rowStyle) ? rowStyle(row, index) : rowStyle;
      var classes = _utils2.default.isFunction(rowClasses) ? rowClasses(row, index) : rowClasses;
      if (selected) {
        var selectedStyle = _utils2.default.isFunction(selectRow.style) ? selectRow.style(row, index) : selectRow.style;

        var selectedClasses = _utils2.default.isFunction(selectRow.classes) ? selectRow.classes(row, index) : selectRow.classes;

        style = _extends({}, style, selectedStyle);
        classes = (0, _classnames2.default)(classes, selectedClasses);

        if (bgColor) {
          style = style || {};
          style.backgroundColor = _utils2.default.isFunction(bgColor) ? bgColor(row, index) : bgColor;
        }
      }

      var selectable = !nonSelectable || !nonSelectable.includes(key);

      return _react2.default.createElement(_row2.default, {
        key: key,
        row: row,
        keyField: keyField,
        rowIndex: index,
        columns: columns,
        cellEdit: cellEdit,
        editable: editable,
        selectable: selectable,
        selected: selected,
        selectRow: selectRow,
        style: style,
        className: classes,
        attrs: attrs
      });
    });
  }

  return _react2.default.createElement(
    'tbody',
    null,
    content
  );
};

Body.propTypes = {
  keyField: _propTypes2.default.string.isRequired,
  data: _propTypes2.default.array.isRequired,
  columns: _propTypes2.default.array.isRequired,
  selectRow: _propTypes2.default.object,
  selectedRowKeys: _propTypes2.default.array
};

exports.default = Body;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _cell = __webpack_require__(22);

var _cell2 = _interopRequireDefault(_cell);

var _selectionCell = __webpack_require__(23);

var _selectionCell2 = _interopRequireDefault(_selectionCell);

var _rowEventDelegater = __webpack_require__(24);

var _rowEventDelegater2 = _interopRequireDefault(_rowEventDelegater);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */
/* eslint react/no-array-index-key: 0 */


var Row = function (_eventDelegater) {
  _inherits(Row, _eventDelegater);

  function Row() {
    _classCallCheck(this, Row);

    return _possibleConstructorReturn(this, (Row.__proto__ || Object.getPrototypeOf(Row)).apply(this, arguments));
  }

  _createClass(Row, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          row = _props.row,
          columns = _props.columns,
          keyField = _props.keyField,
          rowIndex = _props.rowIndex,
          className = _props.className,
          style = _props.style,
          attrs = _props.attrs,
          cellEdit = _props.cellEdit,
          selected = _props.selected,
          selectRow = _props.selectRow,
          selectable = _props.selectable,
          editableRow = _props.editable;

      var mode = cellEdit.mode,
          onStart = cellEdit.onStart,
          EditingCell = cellEdit.EditingCell,
          editingRowIdx = cellEdit.ridx,
          editingColIdx = cellEdit.cidx,
          CLICK_TO_CELL_EDIT = cellEdit.CLICK_TO_CELL_EDIT,
          DBCLICK_TO_CELL_EDIT = cellEdit.DBCLICK_TO_CELL_EDIT,
          rest = _objectWithoutProperties(cellEdit, ['mode', 'onStart', 'EditingCell', 'ridx', 'cidx', 'CLICK_TO_CELL_EDIT', 'DBCLICK_TO_CELL_EDIT']);

      var key = _utils2.default.get(row, keyField);
      var hideSelectColumn = selectRow.hideSelectColumn;

      var trAttrs = this.delegate(attrs);

      return _react2.default.createElement(
        'tr',
        _extends({ style: style, className: className }, trAttrs),
        selectRow.mode !== _const2.default.ROW_SELECT_DISABLED && !hideSelectColumn ? _react2.default.createElement(_selectionCell2.default, _extends({}, selectRow, {
          rowKey: key,
          rowIndex: rowIndex,
          selected: selected,
          disabled: !selectable
        })) : null,
        columns.map(function (column, index) {
          if (!column.hidden) {
            var dataField = column.dataField;

            var content = _utils2.default.get(row, dataField);
            var editable = _utils2.default.isDefined(column.editable) ? column.editable : true;
            if (dataField === keyField || !editableRow) editable = false;
            if (_utils2.default.isFunction(column.editable)) {
              editable = column.editable(content, row, rowIndex, index);
            }
            if (rowIndex === editingRowIdx && index === editingColIdx) {
              var editCellstyle = column.editCellStyle || {};
              var editCellclasses = column.editCellClasses;
              if (_utils2.default.isFunction(column.editCellStyle)) {
                editCellstyle = column.editCellStyle(content, row, rowIndex, index);
              }
              if (_utils2.default.isFunction(column.editCellClasses)) {
                editCellclasses = column.editCellClasses(content, row, rowIndex, index);
              }
              return _react2.default.createElement(EditingCell, _extends({
                key: content + '-' + index,
                row: row,
                rowIndex: rowIndex,
                column: column,
                columnIndex: index,
                className: editCellclasses,
                style: editCellstyle
              }, rest));
            }
            return _react2.default.createElement(_cell2.default, {
              key: content + '-' + index,
              row: row,
              rowIndex: rowIndex,
              columnIndex: index,
              column: column,
              onStart: onStart,
              editable: editable,
              clickToEdit: mode === CLICK_TO_CELL_EDIT,
              dbclickToEdit: mode === DBCLICK_TO_CELL_EDIT
            });
          }
          return false;
        })
      );
    }
  }]);

  return Row;
}((0, _rowEventDelegater2.default)(_react.Component));

Row.propTypes = {
  row: _propTypes2.default.object.isRequired,
  rowIndex: _propTypes2.default.number.isRequired,
  columns: _propTypes2.default.array.isRequired,
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  attrs: _propTypes2.default.object
};

Row.defaultProps = {
  editable: true,
  style: {},
  className: null,
  attrs: {}
};

exports.default = Row;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


var Cell = function (_Component) {
  _inherits(Cell, _Component);

  function Cell(props) {
    _classCallCheck(this, Cell);

    var _this = _possibleConstructorReturn(this, (Cell.__proto__ || Object.getPrototypeOf(Cell)).call(this, props));

    _this.handleEditingCell = _this.handleEditingCell.bind(_this);
    return _this;
  }

  _createClass(Cell, [{
    key: 'handleEditingCell',
    value: function handleEditingCell(e) {
      var _props = this.props,
          column = _props.column,
          onStart = _props.onStart,
          rowIndex = _props.rowIndex,
          columnIndex = _props.columnIndex,
          clickToEdit = _props.clickToEdit,
          dbclickToEdit = _props.dbclickToEdit;
      var events = column.events;

      if (events) {
        if (clickToEdit) {
          var customClick = events.onClick;
          if (_utils2.default.isFunction(customClick)) customClick(e);
        } else if (dbclickToEdit) {
          var customDbClick = events.onDoubleClick;
          if (_utils2.default.isFunction(customDbClick)) customDbClick(e);
        }
      }
      if (onStart) {
        onStart(rowIndex, columnIndex);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          row = _props2.row,
          rowIndex = _props2.rowIndex,
          column = _props2.column,
          columnIndex = _props2.columnIndex,
          editable = _props2.editable,
          clickToEdit = _props2.clickToEdit,
          dbclickToEdit = _props2.dbclickToEdit;
      var dataField = column.dataField,
          formatter = column.formatter,
          formatExtraData = column.formatExtraData,
          style = column.style,
          classes = column.classes,
          title = column.title,
          events = column.events,
          align = column.align,
          attrs = column.attrs;

      var cellTitle = void 0;
      var cellStyle = {};
      var content = _utils2.default.get(row, dataField);

      var cellAttrs = _extends({}, _utils2.default.isFunction(attrs) ? attrs(content, row, rowIndex, columnIndex) : attrs, events);

      var cellClasses = _utils2.default.isFunction(classes) ? classes(content, row, rowIndex, columnIndex) : classes;

      if (style) {
        cellStyle = _utils2.default.isFunction(style) ? style(content, row, rowIndex, columnIndex) : style;
      }

      if (title) {
        cellTitle = _utils2.default.isFunction(title) ? title(content, row, rowIndex, columnIndex) : content;
        cellAttrs.title = cellTitle;
      }

      if (formatter) {
        content = column.formatter(content, row, rowIndex, formatExtraData);
      }

      if (align) {
        cellStyle.textAlign = _utils2.default.isFunction(align) ? align(content, row, rowIndex, columnIndex) : align;
      }

      if (cellClasses) cellAttrs.className = cellClasses;

      if (!_utils2.default.isEmptyObject(cellStyle)) cellAttrs.style = cellStyle;
      if (clickToEdit && editable) {
        cellAttrs.onClick = this.handleEditingCell;
      } else if (dbclickToEdit && editable) {
        cellAttrs.onDoubleClick = this.handleEditingCell;
      }
      return _react2.default.createElement(
        'td',
        cellAttrs,
        content
      );
    }
  }]);

  return Cell;
}(_react.Component);

Cell.propTypes = {
  row: _propTypes2.default.object.isRequired,
  rowIndex: _propTypes2.default.number.isRequired,
  column: _propTypes2.default.object.isRequired,
  columnIndex: _propTypes2.default.number.isRequired
};

exports.default = Cell;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 react/require-default-props: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 jsx-a11y/no-noninteractive-element-interactions: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */


var SelectionCell = function (_Component) {
  _inherits(SelectionCell, _Component);

  function SelectionCell() {
    _classCallCheck(this, SelectionCell);

    var _this = _possibleConstructorReturn(this, (SelectionCell.__proto__ || Object.getPrototypeOf(SelectionCell)).call(this));

    _this.handleClick = _this.handleClick.bind(_this);
    return _this;
  }

  _createClass(SelectionCell, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      var selected = this.props.selected;


      return nextProps.selected !== selected;
    }
  }, {
    key: 'handleClick',
    value: function handleClick(e) {
      var _props = this.props,
          inputType = _props.mode,
          rowKey = _props.rowKey,
          selected = _props.selected,
          onRowSelect = _props.onRowSelect,
          disabled = _props.disabled,
          rowIndex = _props.rowIndex,
          clickToSelect = _props.clickToSelect;


      if (disabled) return;
      if (clickToSelect) return;

      var checked = inputType === _const2.default.ROW_SELECT_SINGLE ? true : !selected;

      onRowSelect(rowKey, checked, rowIndex, e);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          inputType = _props2.mode,
          selected = _props2.selected,
          disabled = _props2.disabled;


      return _react2.default.createElement(
        'td',
        { onClick: this.handleClick },
        _react2.default.createElement('input', {
          type: inputType,
          checked: selected,
          disabled: disabled
        })
      );
    }
  }]);

  return SelectionCell;
}(_react.Component);

SelectionCell.propTypes = {
  mode: _propTypes2.default.string.isRequired,
  rowKey: _propTypes2.default.any,
  selected: _propTypes2.default.bool,
  onRowSelect: _propTypes2.default.func,
  disabled: _propTypes2.default.bool,
  rowIndex: _propTypes2.default.number,
  clickToSelect: _propTypes2.default.bool
};
exports.default = SelectionCell;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var events = ['onClick', 'onMouseEnter', 'onMouseLeave'];

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(RowEventDelegater, _ExtendBase);

    function RowEventDelegater(props) {
      _classCallCheck(this, RowEventDelegater);

      var _this = _possibleConstructorReturn(this, (RowEventDelegater.__proto__ || Object.getPrototypeOf(RowEventDelegater)).call(this, props));

      _this.clickNum = 0;
      _this.createDefaultEventHandler = _this.createDefaultEventHandler.bind(_this);
      _this.createClickEventHandler = _this.createClickEventHandler.bind(_this);
      return _this;
    }

    _createClass(RowEventDelegater, [{
      key: 'createDefaultEventHandler',
      value: function createDefaultEventHandler(cb) {
        var _this2 = this;

        return function (e) {
          var _props = _this2.props,
              row = _props.row,
              rowIndex = _props.rowIndex;

          cb(e, row, rowIndex);
        };
      }
    }, {
      key: 'createClickEventHandler',
      value: function createClickEventHandler(cb) {
        var _this3 = this;

        return function (e) {
          var _props2 = _this3.props,
              row = _props2.row,
              selected = _props2.selected,
              keyField = _props2.keyField,
              selectable = _props2.selectable,
              rowIndex = _props2.rowIndex,
              _props2$selectRow = _props2.selectRow,
              onRowSelect = _props2$selectRow.onRowSelect,
              clickToEdit = _props2$selectRow.clickToEdit,
              _props2$cellEdit = _props2.cellEdit,
              mode = _props2$cellEdit.mode,
              DBCLICK_TO_CELL_EDIT = _props2$cellEdit.DBCLICK_TO_CELL_EDIT,
              DELAY_FOR_DBCLICK = _props2$cellEdit.DELAY_FOR_DBCLICK;


          var clickFn = function clickFn() {
            if (cb) {
              cb(e, row, rowIndex);
            }
            if (selectable) {
              var key = _utils2.default.get(row, keyField);
              onRowSelect(key, !selected, rowIndex, e);
            }
          };

          if (mode === DBCLICK_TO_CELL_EDIT && clickToEdit) {
            _this3.clickNum += 1;
            _utils2.default.debounce(function () {
              if (_this3.clickNum === 1) {
                clickFn();
              }
              _this3.clickNum = 0;
            }, DELAY_FOR_DBCLICK)();
          } else {
            clickFn();
          }
        };
      }
    }, {
      key: 'delegate',
      value: function delegate() {
        var _this4 = this;

        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var newAttrs = {};
        if (this.props.selectRow && this.props.selectRow.clickToSelect) {
          newAttrs.onClick = this.createClickEventHandler(attrs.onClick);
        }
        Object.keys(attrs).forEach(function (attr) {
          if (!newAttrs[attr]) {
            if (events.includes(attr)) {
              newAttrs[attr] = _this4.createDefaultEventHandler(attrs[attr]);
            } else {
              newAttrs[attr] = attrs[attr];
            }
          }
        });
        return newAttrs;
      }
    }]);

    return RowEventDelegater;
  }(ExtendBase);
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RowSection = function RowSection(_ref) {
  var content = _ref.content,
      colSpan = _ref.colSpan;
  return _react2.default.createElement(
    'tr',
    null,
    _react2.default.createElement(
      'td',
      {
        'data-toggle': 'collapse',
        colSpan: colSpan,
        className: 'react-bs-table-no-data'
      },
      content
    )
  );
};

RowSection.propTypes = {
  content: _propTypes2.default.any,
  colSpan: _propTypes2.default.number
};

RowSection.defaultProps = {
  content: null,
  colSpan: 1
};

exports.default = RowSection;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _columnResolver = __webpack_require__(27);

var _columnResolver2 = _interopRequireDefault(_columnResolver);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ColumnResolver) {
    _inherits(TableResolver, _ColumnResolver);

    function TableResolver() {
      _classCallCheck(this, TableResolver);

      return _possibleConstructorReturn(this, (TableResolver.__proto__ || Object.getPrototypeOf(TableResolver)).apply(this, arguments));
    }

    _createClass(TableResolver, [{
      key: 'validateProps',
      value: function validateProps() {
        var keyField = this.props.keyField;

        if (!keyField) {
          throw new Error('Please specify a field as key via keyField');
        }
        if (this.visibleColumnSize(false) <= 0) {
          throw new Error('No visible columns detected');
        }
      }
    }, {
      key: 'isEmpty',
      value: function isEmpty() {
        return this.props.data.length === 0;
      }

      /**
       * props resolver for cell selection
       * @param {Object} options - addtional options like callback which are about to merge into props
       *
       * @returns {Object} result - props for cell selections
       * @returns {String} result.mode - input type of row selection or disabled.
       */

    }, {
      key: 'resolveSelectRowProps',
      value: function resolveSelectRowProps(options) {
        var selectRow = this.props.selectRow;
        var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED;


        if (_utils2.default.isDefined(selectRow)) {
          return _extends({}, selectRow, options);
        }

        return {
          mode: ROW_SELECT_DISABLED
        };
      }

      /**
       * props resolver for header cell selection
       * @param {Object} options - addtional options like callback which are about to merge into props
       *
       * @returns {Object} result - props for cell selections
       * @returns {String} result.mode - input type of row selection or disabled.
       * @returns {String} result.checkedStatus - checkbox status depending on selected rows counts
       */

    }, {
      key: 'resolveSelectRowPropsForHeader',
      value: function resolveSelectRowPropsForHeader() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var selectRow = this.props.selectRow;

        var allRowsSelected = options.allRowsSelected,
            _options$selected = options.selected,
            selected = _options$selected === undefined ? [] : _options$selected,
            rest = _objectWithoutProperties(options, ['allRowsSelected', 'selected']);

        var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED,
            CHECKBOX_STATUS_CHECKED = _const2.default.CHECKBOX_STATUS_CHECKED,
            CHECKBOX_STATUS_INDETERMINATE = _const2.default.CHECKBOX_STATUS_INDETERMINATE,
            CHECKBOX_STATUS_UNCHECKED = _const2.default.CHECKBOX_STATUS_UNCHECKED;


        if (_utils2.default.isDefined(selectRow)) {
          var checkedStatus = void 0;

          // checkbox status depending on selected rows counts
          if (allRowsSelected) checkedStatus = CHECKBOX_STATUS_CHECKED;else if (selected.length === 0) checkedStatus = CHECKBOX_STATUS_UNCHECKED;else checkedStatus = CHECKBOX_STATUS_INDETERMINATE;

          return _extends({}, selectRow, rest, {
            checkedStatus: checkedStatus
          });
        }

        return {
          mode: ROW_SELECT_DISABLED
        };
      }
    }]);

    return TableResolver;
  }((0, _columnResolver2.default)(ExtendBase));
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(ColumnResolver, _ExtendBase);

    function ColumnResolver() {
      _classCallCheck(this, ColumnResolver);

      return _possibleConstructorReturn(this, (ColumnResolver.__proto__ || Object.getPrototypeOf(ColumnResolver)).apply(this, arguments));
    }

    _createClass(ColumnResolver, [{
      key: "visibleColumnSize",
      value: function visibleColumnSize() {
        var includeSelectColumn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        var columnLen = this.props.columns.filter(function (c) {
          return !c.hidden;
        }).length;
        if (!includeSelectColumn) return columnLen;
        if (this.props.selectRow && !this.props.selectRow.hideSelectColumn) {
          return columnLen + 1;
        }
        return columnLen;
      }
    }]);

    return ColumnResolver;
  }(ExtendBase);
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _store = __webpack_require__(29);

var _store2 = _interopRequireDefault(_store);

var _wrapper = __webpack_require__(31);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _wrapper3 = __webpack_require__(32);

var _wrapper4 = _interopRequireDefault(_wrapper3);

var _remoteResolver2 = __webpack_require__(7);

var _remoteResolver3 = _interopRequireDefault(_remoteResolver2);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-return-assign: 0 */
/* eslint react/prop-types: 0 */


var withDataStore = function withDataStore(Base) {
  return function (_remoteResolver) {
    _inherits(BootstrapTableContainer, _remoteResolver);

    function BootstrapTableContainer(props) {
      _classCallCheck(this, BootstrapTableContainer);

      var _this = _possibleConstructorReturn(this, (BootstrapTableContainer.__proto__ || Object.getPrototypeOf(BootstrapTableContainer)).call(this, props));

      _this.store = new _store2.default(props.keyField);
      _this.store.data = props.data;
      _this.wrapComponents();
      return _this;
    }

    _createClass(BootstrapTableContainer, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.store.setAllData(nextProps.data);
      }
    }, {
      key: 'wrapComponents',
      value: function wrapComponents() {
        this.BaseComponent = Base;
        var _props = this.props,
            pagination = _props.pagination,
            columns = _props.columns,
            filter = _props.filter,
            selectRow = _props.selectRow,
            cellEdit = _props.cellEdit;

        if (pagination) {
          var wrapperFactory = pagination.wrapperFactory;

          this.BaseComponent = wrapperFactory(this.BaseComponent, {
            remoteResolver: _remoteResolver3.default
          });
        }

        if (columns.filter(function (col) {
          return col.sort;
        }).length > 0) {
          this.BaseComponent = (0, _wrapper2.default)(this.BaseComponent);
        }

        if (filter) {
          var _wrapperFactory = filter.wrapperFactory;

          this.BaseComponent = _wrapperFactory(this.BaseComponent, {
            _: _utils2.default,
            remoteResolver: _remoteResolver3.default
          });
        }

        if (cellEdit) {
          var _wrapperFactory2 = cellEdit.wrapperFactory;

          this.BaseComponent = _wrapperFactory2(this.BaseComponent, {
            _: _utils2.default,
            remoteResolver: _remoteResolver3.default
          });
        }

        if (selectRow) {
          this.BaseComponent = (0, _wrapper4.default)(this.BaseComponent);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var baseProps = _extends({}, this.props, {
          store: this.store
        });

        return _react2.default.createElement(this.BaseComponent, baseProps);
      }
    }]);

    return BootstrapTableContainer;
  }((0, _remoteResolver3.default)(_react.Component));
};

exports.default = withDataStore;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-underscore-dangle: 0 */


var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _sort = __webpack_require__(30);

var _rows = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Store = function () {
  function Store(keyField) {
    _classCallCheck(this, Store);

    this._data = [];
    this._filteredData = [];
    this._keyField = keyField;
    this._sortOrder = undefined;
    this._sortField = undefined;
    this._selected = [];
    this._filters = {};
    this._page = undefined;
    this._sizePerPage = undefined;
  }

  _createClass(Store, [{
    key: 'edit',
    value: function edit(rowId, dataField, newValue) {
      var row = (0, _rows.getRowByRowId)(this)(rowId);
      if (row) _utils2.default.set(row, dataField, newValue);
    }
  }, {
    key: 'setSort',
    value: function setSort(_ref, order, defaultOrder) {
      var dataField = _ref.dataField;

      this.sortOrder = (0, _sort.nextOrder)(this)(dataField, order, defaultOrder);
      this.sortField = dataField;
    }
  }, {
    key: 'sortBy',
    value: function sortBy(_ref2) {
      var sortFunc = _ref2.sortFunc;

      this.data = (0, _sort.sort)(this)(sortFunc);
    }
  }, {
    key: 'getAllData',
    value: function getAllData() {
      return this._data;
    }
  }, {
    key: 'setAllData',
    value: function setAllData(data) {
      this._data = data;
    }
  }, {
    key: 'data',
    get: function get() {
      if (Object.keys(this._filters).length > 0) {
        return this._filteredData;
      }
      return this._data;
    },
    set: function set(data) {
      if (Object.keys(this._filters).length > 0) {
        this._filteredData = data;
      } else {
        this._data = data ? JSON.parse(JSON.stringify(data)) : [];
      }
    }
  }, {
    key: 'filteredData',
    get: function get() {
      return this._filteredData;
    },
    set: function set(filteredData) {
      this._filteredData = filteredData;
    }
  }, {
    key: 'keyField',
    get: function get() {
      return this._keyField;
    },
    set: function set(keyField) {
      this._keyField = keyField;
    }
  }, {
    key: 'sortOrder',
    get: function get() {
      return this._sortOrder;
    },
    set: function set(sortOrder) {
      this._sortOrder = sortOrder;
    }
  }, {
    key: 'page',
    get: function get() {
      return this._page;
    },
    set: function set(page) {
      this._page = page;
    }
  }, {
    key: 'sizePerPage',
    get: function get() {
      return this._sizePerPage;
    },
    set: function set(sizePerPage) {
      this._sizePerPage = sizePerPage;
    }
  }, {
    key: 'sortField',
    get: function get() {
      return this._sortField;
    },
    set: function set(sortField) {
      this._sortField = sortField;
    }
  }, {
    key: 'selected',
    get: function get() {
      return this._selected;
    },
    set: function set(selected) {
      this._selected = selected;
    }
  }, {
    key: 'filters',
    get: function get() {
      return this._filters;
    },
    set: function set(filters) {
      this._filters = filters;
    }
  }]);

  return Store;
}();

exports.default = Store;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nextOrder = exports.sort = undefined;

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /* eslint no-nested-ternary: 0 */
/* eslint no-lonely-if: 0 */
/* eslint no-underscore-dangle: 0 */


function comparator(a, b) {
  var result = void 0;
  if (typeof b === 'string') {
    result = b.localeCompare(a);
  } else {
    result = a > b ? -1 : a < b ? 1 : 0;
  }
  return result;
}

var sort = exports.sort = function sort(_ref) {
  var data = _ref.data,
      sortOrder = _ref.sortOrder,
      sortField = _ref.sortField;
  return function (sortFunc) {
    var _data = [].concat(_toConsumableArray(data));
    _data.sort(function (a, b) {
      var result = void 0;
      var valueA = _utils2.default.get(a, sortField);
      var valueB = _utils2.default.get(b, sortField);
      valueA = _utils2.default.isDefined(valueA) ? valueA : '';
      valueB = _utils2.default.isDefined(valueB) ? valueB : '';

      if (sortFunc) {
        result = sortFunc(valueA, valueB, sortOrder, sortField);
      } else {
        if (sortOrder === _const2.default.SORT_DESC) {
          result = comparator(valueA, valueB);
        } else {
          result = comparator(valueB, valueA);
        }
      }
      return result;
    });
    return _data;
  };
};

var nextOrder = exports.nextOrder = function nextOrder(store) {
  return function (field, order) {
    var defaultOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const2.default.SORT_DESC;

    if (order) return order;

    if (field !== store.sortField) {
      return defaultOrder;
    }
    return store.sortOrder === _const2.default.SORT_DESC ? _const2.default.SORT_ASC : _const2.default.SORT_DESC;
  };
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _remoteResolver2 = __webpack_require__(7);

var _remoteResolver3 = _interopRequireDefault(_remoteResolver2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


exports.default = function (Base) {
  var _class, _temp;

  return _temp = _class = function (_remoteResolver) {
    _inherits(SortWrapper, _remoteResolver);

    function SortWrapper(props) {
      _classCallCheck(this, SortWrapper);

      var _this = _possibleConstructorReturn(this, (SortWrapper.__proto__ || Object.getPrototypeOf(SortWrapper)).call(this, props));

      _this.handleSort = _this.handleSort.bind(_this);
      return _this;
    }

    _createClass(SortWrapper, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var _props = this.props,
            columns = _props.columns,
            defaultSorted = _props.defaultSorted,
            defaultSortDirection = _props.defaultSortDirection,
            store = _props.store;
        // defaultSorted is an array, it's ready to use as multi / single sort
        // when we start to support multi sort, please update following code to use array.forEach

        if (defaultSorted && defaultSorted.length > 0) {
          var dataField = defaultSorted[0].dataField;
          var order = defaultSorted[0].order;
          var column = columns.filter(function (col) {
            return col.dataField === dataField;
          });
          if (column.length > 0) {
            store.setSort(column[0], order, defaultSortDirection);

            if (column[0].onSort) {
              column[0].onSort(store.sortField, store.sortOrder);
            }

            if (this.isRemoteSort() || this.isRemotePagination()) {
              this.handleSortChange();
            } else {
              store.sortBy(column[0]);
            }
          }
        }
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var sortedColumn = void 0;
        for (var i = 0; i < nextProps.columns.length; i += 1) {
          if (nextProps.columns[i].dataField === nextProps.store.sortField) {
            sortedColumn = nextProps.columns[i];
            break;
          }
        }
        if (sortedColumn && sortedColumn.sort) {
          nextProps.store.sortBy(sortedColumn);
        }
      }
    }, {
      key: 'handleSort',
      value: function handleSort(column) {
        var store = this.props.store;

        store.setSort(column, undefined, this.props.defaultSortDirection);

        if (column.onSort) {
          column.onSort(store.sortField, store.sortOrder);
        }

        if (this.isRemoteSort() || this.isRemotePagination()) {
          this.handleSortChange();
        } else {
          store.sortBy(column);
          this.forceUpdate();
        }
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(Base, _extends({}, this.props, {
          onSort: this.handleSort,
          data: this.props.store.data
        }));
      }
    }]);

    return SortWrapper;
  }((0, _remoteResolver3.default)(_react.Component)), _class.propTypes = {
    store: _propTypes2.default.object.isRequired
  }, _temp;
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _selection = __webpack_require__(6);

var _rows = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-param-reassign: 0 */


exports.default = function (Base) {
  var _class, _temp;

  return _temp = _class = function (_Component) {
    _inherits(RowSelectionWrapper, _Component);

    function RowSelectionWrapper(props) {
      _classCallCheck(this, RowSelectionWrapper);

      var _this = _possibleConstructorReturn(this, (RowSelectionWrapper.__proto__ || Object.getPrototypeOf(RowSelectionWrapper)).call(this, props));

      _this.handleRowSelect = _this.handleRowSelect.bind(_this);
      _this.handleAllRowsSelect = _this.handleAllRowsSelect.bind(_this);

      props.store.selected = props.selectRow.selected || [];
      _this.state = {
        selectedRowKeys: props.store.selected
      };
      return _this;
    }

    _createClass(RowSelectionWrapper, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        nextProps.store.selected = nextProps.selectRow.selected || [];
        this.setState(function () {
          return {
            selectedRowKeys: nextProps.store.selected
          };
        });
      }

      /**
       * row selection handler
       * @param {String} rowKey - row key of what was selected.
       * @param {Boolean} checked - next checked status of input button.
       */

    }, {
      key: 'handleRowSelect',
      value: function handleRowSelect(rowKey, checked, rowIndex, e) {
        var _props = this.props,
            _props$selectRow = _props.selectRow,
            mode = _props$selectRow.mode,
            onSelect = _props$selectRow.onSelect,
            store = _props.store;
        var ROW_SELECT_SINGLE = _const2.default.ROW_SELECT_SINGLE;


        var currSelected = [].concat(_toConsumableArray(store.selected));

        if (mode === ROW_SELECT_SINGLE) {
          // when select mode is radio
          currSelected = [rowKey];
        } else if (checked) {
          // when select mode is checkbox
          currSelected.push(rowKey);
        } else {
          currSelected = currSelected.filter(function (value) {
            return value !== rowKey;
          });
        }

        store.selected = currSelected;

        if (onSelect) {
          var row = (0, _rows.getRowByRowId)(store)(rowKey);
          onSelect(row, checked, rowIndex, e);
        }

        this.setState(function () {
          return {
            selectedRowKeys: currSelected
          };
        });
      }

      /**
       * handle all rows selection on header cell by store.selected
       */

    }, {
      key: 'handleAllRowsSelect',
      value: function handleAllRowsSelect(e) {
        var _props2 = this.props,
            store = _props2.store,
            _props2$selectRow = _props2.selectRow,
            onSelectAll = _props2$selectRow.onSelectAll,
            nonSelectable = _props2$selectRow.nonSelectable;

        var selected = (0, _selection.isAnySelectedRow)(store)(nonSelectable);

        var result = !selected;

        var currSelected = result ? (0, _selection.selectableKeys)(store)(nonSelectable) : (0, _selection.unSelectableKeys)(store)(nonSelectable);

        store.selected = currSelected;

        if (onSelectAll) {
          onSelectAll(result, (0, _selection.getSelectedRows)(store), e);
        }

        this.setState(function () {
          return {
            selectedRowKeys: currSelected
          };
        });
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(Base, _extends({}, this.props, {
          onRowSelect: this.handleRowSelect,
          onAllRowsSelect: this.handleAllRowsSelect
        }));
      }
    }]);

    return RowSelectionWrapper;
  }(_react.Component), _class.propTypes = {
    store: _propTypes2.default.object.isRequired,
    selectRow: _propTypes2.default.object.isRequired
  }, _temp;
};

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBjNTVkNDhhZjQ4ZTZiM2U1ZjhhMCIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL3Jvd3MuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvc2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Byb3BzLXJlc29sdmVyL3JlbW90ZS1yZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2Jvb3RzdHJhcC10YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvaGVhZGVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2hlYWRlci1jZWxsLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3NvcnQvc3ltYm9sLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3NvcnQvY2FyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LXNlbGVjdGlvbi9zZWxlY3Rpb24taGVhZGVyLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY2FwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9ib2R5LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jZWxsLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1zZWxlY3Rpb24vc2VsZWN0aW9uLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LWV2ZW50LWRlbGVnYXRlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9jb2x1bW4tcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL3NvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc29ydC93cmFwcGVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1zZWxlY3Rpb24vd3JhcHBlci5qcyJdLCJuYW1lcyI6WyJTT1JUX0FTQyIsIlNPUlRfREVTQyIsIlJPV19TRUxFQ1RfU0lOR0xFIiwiUk9XX1NFTEVDVF9NVUxUSVBMRSIsIlJPV19TRUxFQ1RfRElTQUJMRUQiLCJDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRCIsIkNIRUNLQk9YX1NUQVRVU19JTkRFVEVSTUlOQVRFIiwiQ0hFQ0tCT1hfU1RBVFVTX1VOQ0hFQ0tFRCIsInNwbGl0TmVzdGVkIiwic3RyIiwiam9pbiIsInJlcGxhY2UiLCJzcGxpdCIsImdldCIsInRhcmdldCIsImZpZWxkIiwicGF0aEFycmF5IiwicmVzdWx0IiwicmVkdWNlIiwiY3VyciIsInBhdGgiLCJlIiwic2V0IiwidmFsdWUiLCJzYWZlIiwibGV2ZWwiLCJhIiwiYiIsIkVycm9yIiwibGVuZ3RoIiwiaXNGdW5jdGlvbiIsIm9iaiIsImlzT2JqZWN0IiwidHlwZSIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiaXNFbXB0eU9iamVjdCIsImhhc093blByb3BlcnR5IiwicHJvdG90eXBlIiwia2V5cyIsImkiLCJjYWxsIiwiaXNEZWZpbmVkIiwic2xlZXAiLCJmbiIsIm1zIiwic2V0VGltZW91dCIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJpbW1lZGlhdGUiLCJ0aW1lb3V0IiwibGF0ZXIiLCJhcHBseSIsImNhbGxOb3ciLCJjbGVhclRpbWVvdXQiLCJhcHB5IiwibWF0Y2hSb3ciLCJrZXlGaWVsZCIsImlkIiwicm93IiwiZ2V0Um93QnlSb3dJZCIsImRhdGEiLCJmaW5kIiwiaXNTZWxlY3RlZEFsbCIsInNlbGVjdGVkIiwiaXNBbnlTZWxlY3RlZFJvdyIsInNraXBzIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJ4Iiwic2VsZWN0YWJsZUtleXMiLCJtYXAiLCJ1blNlbGVjdGFibGVLZXlzIiwiZ2V0U2VsZWN0ZWRSb3dzIiwic3RvcmUiLCJnZXRSb3ciLCJrIiwic3RhdGUiLCJwcm9wcyIsInBhZ2UiLCJzaXplUGVyUGFnZSIsImZpbHRlcnMiLCJzb3J0RmllbGQiLCJzb3J0T3JkZXIiLCJnZXRBbGxEYXRhIiwicmVtb3RlIiwicGFnaW5hdGlvbiIsInNvcnQiLCJjZWxsRWRpdCIsIm9uVGFibGVDaGFuZ2UiLCJnZXROZXdlc3RTdGF0ZSIsIm5ld1N0YXRlIiwiaXNSZW1vdGVQYWdpbmF0aW9uIiwib3B0aW9ucyIsInBhZ2VTdGFydEluZGV4Iiwicm93SWQiLCJkYXRhRmllbGQiLCJuZXdWYWx1ZSIsIkV4dGVuZEJhc2UiLCJCb290c3RyYXBUYWJsZSIsInZhbGlkYXRlUHJvcHMiLCJuZXh0UHJvcHMiLCJzZXRTdGF0ZSIsImxvYWRpbmciLCJvdmVybGF5IiwidGFibGUiLCJyZW5kZXJUYWJsZSIsIkxvYWRpbmdPdmVybGF5IiwiY29sdW1ucyIsImNsYXNzZXMiLCJzdHJpcGVkIiwiaG92ZXIiLCJib3JkZXJlZCIsImNvbmRlbnNlZCIsIm5vRGF0YUluZGljYXRpb24iLCJjYXB0aW9uIiwicm93U3R5bGUiLCJyb3dDbGFzc2VzIiwicm93RXZlbnRzIiwidGFibGVDbGFzcyIsImNlbGxTZWxlY3Rpb25JbmZvIiwicmVzb2x2ZVNlbGVjdFJvd1Byb3BzIiwib25Sb3dTZWxlY3QiLCJoZWFkZXJDZWxsU2VsZWN0aW9uSW5mbyIsInJlc29sdmVTZWxlY3RSb3dQcm9wc0ZvckhlYWRlciIsIm9uQWxsUm93c1NlbGVjdCIsImFsbFJvd3NTZWxlY3RlZCIsInRhYmxlQ2FwdGlvbiIsIm9uU29ydCIsIm9uRmlsdGVyIiwiaXNFbXB0eSIsInZpc2libGVDb2x1bW5TaXplIiwicHJvcFR5cGVzIiwic3RyaW5nIiwiaXNSZXF1aXJlZCIsImFycmF5Iiwib25lT2ZUeXBlIiwiYm9vbCIsInNoYXBlIiwib2JqZWN0Iiwibm9kZSIsInNlbGVjdFJvdyIsIm1vZGUiLCJvbmVPZiIsImNsaWNrVG9TZWxlY3QiLCJjbGlja1RvRWRpdCIsIm9uU2VsZWN0Iiwib25TZWxlY3RBbGwiLCJzdHlsZSIsIm5vblNlbGVjdGFibGUiLCJiZ0NvbG9yIiwiaGlkZVNlbGVjdENvbHVtbiIsImRlZmF1bHRTb3J0ZWQiLCJhcnJheU9mIiwib3JkZXIiLCJkZWZhdWx0U29ydERpcmVjdGlvbiIsImRlZmF1bHRQcm9wcyIsIkhlYWRlciIsImNvbHVtbiIsImhpZGRlbiIsImN1cnJTb3J0IiwiaXNMYXN0U29ydGluZyIsIkhlYWRlckNlbGwiLCJpbmRleCIsInNvcnRpbmciLCJ0ZXh0IiwiaGVhZGVyVGl0bGUiLCJoZWFkZXJBbGlnbiIsImhlYWRlckZvcm1hdHRlciIsImhlYWRlckV2ZW50cyIsImhlYWRlckNsYXNzZXMiLCJoZWFkZXJTdHlsZSIsImhlYWRlckF0dHJzIiwiaGVhZGVyU29ydGluZ0NsYXNzZXMiLCJoZWFkZXJTb3J0aW5nU3R5bGUiLCJjZWxsQXR0cnMiLCJzb3J0U3ltYm9sIiwiZmlsdGVyRWxtIiwiY2VsbFN0eWxlIiwiY2VsbENsYXNzZXMiLCJ0aXRsZSIsInRleHRBbGlnbiIsImN1c3RvbUNsaWNrIiwib25DbGljayIsImNsYXNzTmFtZSIsImNoaWxkcmVuIiwic29ydEVsZW1lbnQiLCJmaWx0ZXJFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImZvcm1hdHRlciIsImZvcm1hdEV4dHJhRGF0YSIsImFueSIsImV2ZW50cyIsImFsaWduIiwiYXR0cnMiLCJzb3J0RnVuYyIsImVkaXRhYmxlIiwiZWRpdENlbGxTdHlsZSIsImVkaXRDZWxsQ2xhc3NlcyIsImVkaXRvclN0eWxlIiwiZWRpdG9yQ2xhc3NlcyIsInZhbGlkYXRvciIsImZpbHRlclZhbHVlIiwibnVtYmVyIiwiU29ydFN5bWJvbCIsIlNvcnRDYXJldCIsIm9yZGVyQ2xhc3MiLCJkcm9wdXAiLCJDaGVja0JveCIsImNoZWNrZWQiLCJpbmRldGVybWluYXRlIiwiaW5wdXQiLCJTZWxlY3Rpb25IZWFkZXJDZWxsIiwiaGFuZGxlQ2hlY2tCb3hDbGljayIsImJpbmQiLCJjaGVja2VkU3RhdHVzIiwiQ2FwdGlvbiIsIkJvZHkiLCJzZWxlY3RlZFJvd0tleXMiLCJjb250ZW50IiwiaW5kaWNhdGlvbiIsIm5vbkVkaXRhYmxlUm93cyIsImtleSIsImluZGV4T2YiLCJzZWxlY3RlZFN0eWxlIiwic2VsZWN0ZWRDbGFzc2VzIiwiYmFja2dyb3VuZENvbG9yIiwic2VsZWN0YWJsZSIsIlJvdyIsInJvd0luZGV4IiwiZWRpdGFibGVSb3ciLCJvblN0YXJ0IiwiRWRpdGluZ0NlbGwiLCJlZGl0aW5nUm93SWR4IiwicmlkeCIsImVkaXRpbmdDb2xJZHgiLCJjaWR4IiwiQ0xJQ0tfVE9fQ0VMTF9FRElUIiwiREJDTElDS19UT19DRUxMX0VESVQiLCJyZXN0IiwidHJBdHRycyIsImRlbGVnYXRlIiwiZWRpdENlbGxzdHlsZSIsImVkaXRDZWxsY2xhc3NlcyIsIkNlbGwiLCJoYW5kbGVFZGl0aW5nQ2VsbCIsImNvbHVtbkluZGV4IiwiZGJjbGlja1RvRWRpdCIsImN1c3RvbURiQ2xpY2siLCJvbkRvdWJsZUNsaWNrIiwiY2VsbFRpdGxlIiwiU2VsZWN0aW9uQ2VsbCIsImhhbmRsZUNsaWNrIiwiaW5wdXRUeXBlIiwicm93S2V5IiwiZGlzYWJsZWQiLCJjbGlja051bSIsImNyZWF0ZURlZmF1bHRFdmVudEhhbmRsZXIiLCJjcmVhdGVDbGlja0V2ZW50SGFuZGxlciIsImNiIiwiREVMQVlfRk9SX0RCQ0xJQ0siLCJjbGlja0ZuIiwibmV3QXR0cnMiLCJmb3JFYWNoIiwiYXR0ciIsIlJvd1NlY3Rpb24iLCJjb2xTcGFuIiwiaW5jbHVkZVNlbGVjdENvbHVtbiIsImNvbHVtbkxlbiIsImMiLCJ3aXRoRGF0YVN0b3JlIiwid3JhcENvbXBvbmVudHMiLCJzZXRBbGxEYXRhIiwiQmFzZUNvbXBvbmVudCIsIkJhc2UiLCJ3cmFwcGVyRmFjdG9yeSIsInJlbW90ZVJlc29sdmVyIiwiY29sIiwiXyIsImJhc2VQcm9wcyIsIlN0b3JlIiwiX2RhdGEiLCJfZmlsdGVyZWREYXRhIiwiX2tleUZpZWxkIiwiX3NvcnRPcmRlciIsInVuZGVmaW5lZCIsIl9zb3J0RmllbGQiLCJfc2VsZWN0ZWQiLCJfZmlsdGVycyIsIl9wYWdlIiwiX3NpemVQZXJQYWdlIiwiZGVmYXVsdE9yZGVyIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZmlsdGVyZWREYXRhIiwiY29tcGFyYXRvciIsImxvY2FsZUNvbXBhcmUiLCJ2YWx1ZUEiLCJ2YWx1ZUIiLCJuZXh0T3JkZXIiLCJoYW5kbGVTb3J0Iiwic2V0U29ydCIsImlzUmVtb3RlU29ydCIsImhhbmRsZVNvcnRDaGFuZ2UiLCJzb3J0QnkiLCJzb3J0ZWRDb2x1bW4iLCJmb3JjZVVwZGF0ZSIsImhhbmRsZVJvd1NlbGVjdCIsImhhbmRsZUFsbFJvd3NTZWxlY3QiLCJjdXJyU2VsZWN0ZWQiLCJwdXNoIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN0RBLCtDOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztrQkM3QmU7QUFDYkEsWUFBVSxLQURHO0FBRWJDLGFBQVcsTUFGRTtBQUdiQyxxQkFBbUIsT0FITjtBQUliQyx1QkFBcUIsVUFKUjtBQUtiQyx1QkFBcUIscUJBTFI7QUFNYkMsMkJBQXlCLFNBTlo7QUFPYkMsaUNBQStCLGVBUGxCO0FBUWJDLDZCQUEyQjtBQVJkLEM7Ozs7Ozs7Ozs7Ozs7OztBQ0FmO0FBQ0E7QUFDQTs7QUFFQSxTQUFTQyxXQUFULENBQXFCQyxHQUFyQixFQUEwQjtBQUN4QixTQUFPLENBQUNBLEdBQUQsRUFDSkMsSUFESSxDQUNDLEdBREQsRUFFSkMsT0FGSSxDQUVJLEtBRkosRUFFVyxHQUZYLEVBR0pBLE9BSEksQ0FHSSxLQUhKLEVBR1csRUFIWCxFQUlKQyxLQUpJLENBSUUsR0FKRixDQUFQO0FBS0Q7O0FBRUQsU0FBU0MsR0FBVCxDQUFhQyxNQUFiLEVBQXFCQyxLQUFyQixFQUE0QjtBQUMxQixNQUFNQyxZQUFZUixZQUFZTyxLQUFaLENBQWxCO0FBQ0EsTUFBSUUsZUFBSjtBQUNBLE1BQUk7QUFDRkEsYUFBU0QsVUFBVUUsTUFBVixDQUFpQixVQUFDQyxJQUFELEVBQU9DLElBQVA7QUFBQSxhQUFnQkQsS0FBS0MsSUFBTCxDQUFoQjtBQUFBLEtBQWpCLEVBQTZDTixNQUE3QyxDQUFUO0FBQ0QsR0FGRCxDQUVFLE9BQU9PLENBQVAsRUFBVSxDQUFFO0FBQ2QsU0FBT0osTUFBUDtBQUNEOztBQUVELFNBQVNLLEdBQVQsQ0FBYVIsTUFBYixFQUFxQkMsS0FBckIsRUFBNEJRLEtBQTVCLEVBQWlEO0FBQUEsTUFBZEMsSUFBYyx1RUFBUCxLQUFPOztBQUMvQyxNQUFNUixZQUFZUixZQUFZTyxLQUFaLENBQWxCO0FBQ0EsTUFBSVUsUUFBUSxDQUFaO0FBQ0FULFlBQVVFLE1BQVYsQ0FBaUIsVUFBQ1EsQ0FBRCxFQUFJQyxDQUFKLEVBQVU7QUFDekJGLGFBQVMsQ0FBVDtBQUNBLFFBQUksT0FBT0MsRUFBRUMsQ0FBRixDQUFQLEtBQWdCLFdBQXBCLEVBQWlDO0FBQy9CLFVBQUksQ0FBQ0gsSUFBTCxFQUFXLE1BQU0sSUFBSUksS0FBSixDQUFhRixDQUFiLFNBQWtCQyxDQUFsQixtQkFBTjtBQUNYRCxRQUFFQyxDQUFGLElBQU8sRUFBUDtBQUNBLGFBQU9ELEVBQUVDLENBQUYsQ0FBUDtBQUNEOztBQUVELFFBQUlGLFVBQVVULFVBQVVhLE1BQXhCLEVBQWdDO0FBQzlCSCxRQUFFQyxDQUFGLElBQU9KLEtBQVA7QUFDQSxhQUFPQSxLQUFQO0FBQ0Q7QUFDRCxXQUFPRyxFQUFFQyxDQUFGLENBQVA7QUFDRCxHQWJELEVBYUdiLE1BYkg7QUFjRDs7QUFFRCxTQUFTZ0IsVUFBVCxDQUFvQkMsR0FBcEIsRUFBeUI7QUFDdkIsU0FBT0EsT0FBUSxPQUFPQSxHQUFQLEtBQWUsVUFBOUI7QUFDRDs7QUFFRDs7Ozs7QUFLQSxTQUFTQyxRQUFULENBQWtCRCxHQUFsQixFQUF1QjtBQUNyQixNQUFNRSxjQUFjRixHQUFkLHlDQUFjQSxHQUFkLENBQU47QUFDQSxTQUFPQSxRQUFRLElBQVIsSUFBZ0JFLFNBQVMsUUFBekIsSUFBcUNGLElBQUlHLFdBQUosS0FBb0JDLE1BQWhFO0FBQ0Q7O0FBRUQsU0FBU0MsYUFBVCxDQUF1QkwsR0FBdkIsRUFBNEI7QUFDMUIsTUFBSSxDQUFDQyxTQUFTRCxHQUFULENBQUwsRUFBb0IsT0FBTyxLQUFQOztBQUVwQixNQUFNTSxpQkFBaUJGLE9BQU9HLFNBQVAsQ0FBaUJELGNBQXhDO0FBQ0EsTUFBTUUsT0FBT0osT0FBT0ksSUFBUCxDQUFZUixHQUFaLENBQWI7O0FBRUEsT0FBSyxJQUFJUyxJQUFJLENBQWIsRUFBZ0JBLElBQUlELEtBQUtWLE1BQXpCLEVBQWlDVyxLQUFLLENBQXRDLEVBQXlDO0FBQ3ZDLFFBQUlILGVBQWVJLElBQWYsQ0FBb0JWLEdBQXBCLEVBQXlCUSxLQUFLQyxDQUFMLENBQXpCLENBQUosRUFBdUMsT0FBTyxLQUFQO0FBQ3hDOztBQUVELFNBQU8sSUFBUDtBQUNEOztBQUVELFNBQVNFLFNBQVQsQ0FBbUJuQixLQUFuQixFQUEwQjtBQUN4QixTQUFPLE9BQU9BLEtBQVAsS0FBaUIsV0FBakIsSUFBZ0NBLFVBQVUsSUFBakQ7QUFDRDs7QUFFRCxTQUFTb0IsS0FBVCxDQUFlQyxFQUFmLEVBQW1CQyxFQUFuQixFQUF1QjtBQUNyQixTQUFPQyxXQUFXO0FBQUEsV0FBTUYsSUFBTjtBQUFBLEdBQVgsRUFBdUJDLEVBQXZCLENBQVA7QUFDRDs7QUFFRCxTQUFTRSxRQUFULENBQWtCQyxJQUFsQixFQUF3QkMsSUFBeEIsRUFBOEJDLFNBQTlCLEVBQXlDO0FBQUE7QUFBQTs7QUFDdkMsTUFBSUMsZ0JBQUo7O0FBRUEsU0FBTyxZQUFNO0FBQ1gsUUFBTUMsUUFBUSxTQUFSQSxLQUFRLEdBQU07QUFDbEJELGdCQUFVLElBQVY7O0FBRUEsVUFBSSxDQUFDRCxTQUFMLEVBQWdCO0FBQ2RGLGFBQUtLLEtBQUw7QUFDRDtBQUNGLEtBTkQ7O0FBUUEsUUFBTUMsVUFBVUosYUFBYSxDQUFDQyxPQUE5Qjs7QUFFQUksaUJBQWFKLE9BQWI7QUFDQUEsY0FBVUwsV0FBV00sS0FBWCxFQUFrQkgsUUFBUSxDQUExQixDQUFWOztBQUVBLFFBQUlLLE9BQUosRUFBYTtBQUNYTixXQUFLUSxJQUFMO0FBQ0Q7QUFDRixHQWpCRDtBQWtCRDs7a0JBRWM7QUFDYjNDLFVBRGE7QUFFYlMsVUFGYTtBQUdiUSx3QkFIYTtBQUliRSxvQkFKYTtBQUtiSSw4QkFMYTtBQU1iTSxzQkFOYTtBQU9iQyxjQVBhO0FBUWJJO0FBUmEsQzs7Ozs7O0FDbEdmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUFBO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDOUNNLElBQU1VLDhCQUFXLFNBQVhBLFFBQVcsQ0FBQ0MsUUFBRCxFQUFXQyxFQUFYO0FBQUEsU0FBa0I7QUFBQSxXQUFPQyxJQUFJRixRQUFKLE1BQWtCQyxFQUF6QjtBQUFBLEdBQWxCO0FBQUEsQ0FBakI7O0FBRUEsSUFBTUUsd0NBQWdCLFNBQWhCQSxhQUFnQjtBQUFBLE1BQUdDLElBQUgsUUFBR0EsSUFBSDtBQUFBLE1BQVNKLFFBQVQsUUFBU0EsUUFBVDtBQUFBLFNBQXdCO0FBQUEsV0FBTUksS0FBS0MsSUFBTCxDQUFVTixTQUFTQyxRQUFULEVBQW1CQyxFQUFuQixDQUFWLENBQU47QUFBQSxHQUF4QjtBQUFBLENBQXRCLEM7Ozs7Ozs7Ozs7Ozs7O0FDSFA7Ozs7QUFDQTs7OztBQUVPLElBQU1LLHdDQUFnQixTQUFoQkEsYUFBZ0I7QUFBQSxNQUFHRixJQUFILFFBQUdBLElBQUg7QUFBQSxNQUFTRyxRQUFULFFBQVNBLFFBQVQ7QUFBQSxTQUF3QkgsS0FBS2pDLE1BQUwsS0FBZ0JvQyxTQUFTcEMsTUFBakQ7QUFBQSxDQUF0Qjs7QUFFQSxJQUFNcUMsOENBQW1CLFNBQW5CQSxnQkFBbUI7QUFBQSxNQUFHRCxRQUFILFNBQUdBLFFBQUg7QUFBQSxTQUFrQixZQUFnQjtBQUFBLFFBQWZFLEtBQWUsdUVBQVAsRUFBTzs7QUFDaEUsUUFBSUEsTUFBTXRDLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7QUFDdEIsYUFBT29DLFNBQVNwQyxNQUFULEdBQWtCLENBQXpCO0FBQ0Q7QUFDRCxXQUFPb0MsU0FBU0csTUFBVCxDQUFnQjtBQUFBLGFBQUssQ0FBQ0QsTUFBTUUsUUFBTixDQUFlQyxDQUFmLENBQU47QUFBQSxLQUFoQixFQUF5Q3pDLE1BQWhEO0FBQ0QsR0FMK0I7QUFBQSxDQUF6Qjs7QUFPQSxJQUFNMEMsMENBQWlCLFNBQWpCQSxjQUFpQjtBQUFBLE1BQUdULElBQUgsU0FBR0EsSUFBSDtBQUFBLE1BQVNKLFFBQVQsU0FBU0EsUUFBVDtBQUFBLFNBQXdCLFlBQWdCO0FBQUEsUUFBZlMsS0FBZSx1RUFBUCxFQUFPOztBQUNwRSxRQUFJQSxNQUFNdEMsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QixhQUFPaUMsS0FBS1UsR0FBTCxDQUFTO0FBQUEsZUFBTyxnQkFBRTNELEdBQUYsQ0FBTStDLEdBQU4sRUFBV0YsUUFBWCxDQUFQO0FBQUEsT0FBVCxDQUFQO0FBQ0Q7QUFDRCxXQUFPSSxLQUNKTSxNQURJLENBQ0c7QUFBQSxhQUFPLENBQUNELE1BQU1FLFFBQU4sQ0FBZSxnQkFBRXhELEdBQUYsQ0FBTStDLEdBQU4sRUFBV0YsUUFBWCxDQUFmLENBQVI7QUFBQSxLQURILEVBRUpjLEdBRkksQ0FFQTtBQUFBLGFBQU8sZ0JBQUUzRCxHQUFGLENBQU0rQyxHQUFOLEVBQVdGLFFBQVgsQ0FBUDtBQUFBLEtBRkEsQ0FBUDtBQUdELEdBUDZCO0FBQUEsQ0FBdkI7O0FBU0EsSUFBTWUsOENBQW1CLFNBQW5CQSxnQkFBbUI7QUFBQSxNQUFHUixRQUFILFNBQUdBLFFBQUg7QUFBQSxTQUFrQixZQUFnQjtBQUFBLFFBQWZFLEtBQWUsdUVBQVAsRUFBTzs7QUFDaEUsUUFBSUEsTUFBTXRDLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7QUFDdEIsYUFBTyxFQUFQO0FBQ0Q7QUFDRCxXQUFPb0MsU0FBU0csTUFBVCxDQUFnQjtBQUFBLGFBQUtELE1BQU1FLFFBQU4sQ0FBZUMsQ0FBZixDQUFMO0FBQUEsS0FBaEIsQ0FBUDtBQUNELEdBTCtCO0FBQUEsQ0FBekI7O0FBT0EsSUFBTUksNENBQWtCLFNBQWxCQSxlQUFrQixDQUFDQyxLQUFELEVBQVc7QUFDeEMsTUFBTUMsU0FBUyx5QkFBY0QsS0FBZCxDQUFmO0FBQ0EsU0FBT0EsTUFBTVYsUUFBTixDQUFlTyxHQUFmLENBQW1CO0FBQUEsV0FBS0ksT0FBT0MsQ0FBUCxDQUFMO0FBQUEsR0FBbkIsQ0FBUDtBQUNELENBSE0sQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QlA7Ozs7Ozs7Ozs7OztrQkFFZTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSx1Q0FFZ0I7QUFBQSxZQUFaQyxLQUFZLHVFQUFKLEVBQUk7O0FBQ3pCLFlBQU1ILFFBQVEsS0FBS0EsS0FBTCxJQUFjLEtBQUtJLEtBQUwsQ0FBV0osS0FBdkM7QUFDQTtBQUNFSyxnQkFBTUwsTUFBTUssSUFEZDtBQUVFQyx1QkFBYU4sTUFBTU0sV0FGckI7QUFHRUMsbUJBQVNQLE1BQU1PLE9BSGpCO0FBSUVDLHFCQUFXUixNQUFNUSxTQUpuQjtBQUtFQyxxQkFBV1QsTUFBTVMsU0FMbkI7QUFNRXRCLGdCQUFNYSxNQUFNVSxVQUFOO0FBTlIsV0FPS1AsS0FQTDtBQVNEO0FBYlU7QUFBQTtBQUFBLDJDQWVVO0FBQUEsWUFDWFEsTUFEVyxHQUNBLEtBQUtQLEtBREwsQ0FDWE8sTUFEVzs7QUFFbkIsZUFBT0EsV0FBVyxJQUFYLElBQW9CLGdCQUFFdEQsUUFBRixDQUFXc0QsTUFBWCxLQUFzQkEsT0FBT0MsVUFBeEQ7QUFDRDtBQWxCVTtBQUFBO0FBQUEsMENBb0JTO0FBQUEsWUFDVkQsTUFEVSxHQUNDLEtBQUtQLEtBRE4sQ0FDVk8sTUFEVTs7QUFFbEIsZUFBT0EsV0FBVyxJQUFYLElBQW9CLGdCQUFFdEQsUUFBRixDQUFXc0QsTUFBWCxLQUFzQkEsT0FBT2xCLE1BQXhEO0FBQ0Q7QUF2QlU7QUFBQTtBQUFBLHFDQXlCSTtBQUFBLFlBQ0xrQixNQURLLEdBQ00sS0FBS1AsS0FEWCxDQUNMTyxNQURLOztBQUViLGVBQU9BLFdBQVcsSUFBWCxJQUFvQixnQkFBRXRELFFBQUYsQ0FBV3NELE1BQVgsS0FBc0JBLE9BQU9FLElBQXhEO0FBQ0Q7QUE1QlU7QUFBQTtBQUFBLHlDQThCUTtBQUFBLFlBQ1RGLE1BRFMsR0FDRSxLQUFLUCxLQURQLENBQ1RPLE1BRFM7O0FBRWpCLGVBQU9BLFdBQVcsSUFBWCxJQUFvQixnQkFBRXRELFFBQUYsQ0FBV3NELE1BQVgsS0FBc0JBLE9BQU9HLFFBQXhEO0FBQ0Q7QUFqQ1U7QUFBQTtBQUFBLCtDQW1DYztBQUN2QixhQUFLVixLQUFMLENBQVdXLGFBQVgsQ0FBeUIsWUFBekIsRUFBdUMsS0FBS0MsY0FBTCxFQUF2QztBQUNEO0FBckNVO0FBQUE7QUFBQSxpREF1Q2dCO0FBQ3pCLFlBQU1DLFdBQVcsRUFBakI7QUFDQSxZQUFJLEtBQUtDLGtCQUFMLEVBQUosRUFBK0I7QUFDN0IsY0FBTUMsVUFBVSxLQUFLZixLQUFMLENBQVdRLFVBQVgsQ0FBc0JPLE9BQXRCLElBQWlDLEVBQWpEO0FBQ0FGLG1CQUFTWixJQUFULEdBQWdCLGdCQUFFdEMsU0FBRixDQUFZb0QsUUFBUUMsY0FBcEIsSUFBc0NELFFBQVFDLGNBQTlDLEdBQStELENBQS9FO0FBQ0Q7QUFDRCxhQUFLaEIsS0FBTCxDQUFXVyxhQUFYLENBQXlCLFFBQXpCLEVBQW1DLEtBQUtDLGNBQUwsQ0FBb0JDLFFBQXBCLENBQW5DO0FBQ0Q7QUE5Q1U7QUFBQTtBQUFBLHlDQWdEUTtBQUNqQixhQUFLYixLQUFMLENBQVdXLGFBQVgsQ0FBeUIsTUFBekIsRUFBaUMsS0FBS0MsY0FBTCxFQUFqQztBQUNEO0FBbERVO0FBQUE7QUFBQSx1Q0FvRE1LLEtBcEROLEVBb0RhQyxTQXBEYixFQW9Ed0JDLFFBcER4QixFQW9Ea0M7QUFDM0MsWUFBTVQsV0FBVyxFQUFFTyxZQUFGLEVBQVNDLG9CQUFULEVBQW9CQyxrQkFBcEIsRUFBakI7QUFDQSxhQUFLbkIsS0FBTCxDQUFXVyxhQUFYLENBQXlCLFVBQXpCLEVBQXFDLEtBQUtDLGNBQUwsQ0FBb0IsRUFBRUYsa0JBQUYsRUFBcEIsQ0FBckM7QUFDRDtBQXZEVTs7QUFBQTtBQUFBLElBQ2dCVSxVQURoQjtBQUFBLEM7Ozs7Ozs7Ozs7Ozs7QUNGZjs7OztBQUNBOzs7Ozs7a0JBRWUsa0Q7Ozs7Ozs7Ozs7Ozs7OztBQ0RmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7K2VBWEE7O0lBYU1DLGM7OztBQUNKLDBCQUFZckIsS0FBWixFQUFtQjtBQUFBOztBQUFBLGdJQUNYQSxLQURXOztBQUVqQixVQUFLc0IsYUFBTDs7QUFFQSxVQUFLdkIsS0FBTCxHQUFhO0FBQ1hoQixZQUFNaUIsTUFBTWpCO0FBREQsS0FBYjtBQUppQjtBQU9sQjs7Ozs4Q0FFeUJ3QyxTLEVBQVc7QUFDbkMsV0FBS0MsUUFBTCxDQUFjO0FBQ1p6QyxjQUFNd0MsVUFBVXhDO0FBREosT0FBZDtBQUdEOzs7NkJBRVE7QUFBQSxtQkFDc0IsS0FBS2lCLEtBRDNCO0FBQUEsVUFDQ3lCLE9BREQsVUFDQ0EsT0FERDtBQUFBLFVBQ1VDLE9BRFYsVUFDVUEsT0FEVjs7QUFFUCxVQUFNQyxRQUFRLEtBQUtDLFdBQUwsRUFBZDtBQUNBLFVBQUlILFdBQVdDLE9BQWYsRUFBd0I7QUFDdEIsWUFBTUcsaUJBQWlCSCxRQUFRQyxLQUFSLEVBQWVGLE9BQWYsQ0FBdkI7QUFDQSxlQUFPLDhCQUFDLGNBQUQsT0FBUDtBQUNEO0FBQ0QsYUFBT0UsS0FBUDtBQUNEOzs7a0NBRWE7QUFBQSxvQkFnQlIsS0FBSzNCLEtBaEJHO0FBQUEsVUFFVkosS0FGVSxXQUVWQSxLQUZVO0FBQUEsVUFHVmtDLE9BSFUsV0FHVkEsT0FIVTtBQUFBLFVBSVZuRCxRQUpVLFdBSVZBLFFBSlU7QUFBQSxVQUtWQyxFQUxVLFdBS1ZBLEVBTFU7QUFBQSxVQU1WbUQsT0FOVSxXQU1WQSxPQU5VO0FBQUEsVUFPVkMsT0FQVSxXQU9WQSxPQVBVO0FBQUEsVUFRVkMsS0FSVSxXQVFWQSxLQVJVO0FBQUEsVUFTVkMsUUFUVSxXQVNWQSxRQVRVO0FBQUEsVUFVVkMsU0FWVSxXQVVWQSxTQVZVO0FBQUEsVUFXVkMsZ0JBWFUsV0FXVkEsZ0JBWFU7QUFBQSxVQVlWQyxPQVpVLFdBWVZBLE9BWlU7QUFBQSxVQWFWQyxRQWJVLFdBYVZBLFFBYlU7QUFBQSxVQWNWQyxVQWRVLFdBY1ZBLFVBZFU7QUFBQSxVQWVWQyxTQWZVLFdBZVZBLFNBZlU7OztBQWtCWixVQUFNQyxhQUFhLDBCQUFHLE9BQUgsRUFBWTtBQUM3Qix5QkFBaUJULE9BRFk7QUFFN0IsdUJBQWVDLEtBRmM7QUFHN0IsMEJBQWtCQyxRQUhXO0FBSTdCLDJCQUFtQkM7QUFKVSxPQUFaLEVBS2hCSixPQUxnQixDQUFuQjs7QUFPQSxVQUFNVyxvQkFBb0IsS0FBS0MscUJBQUwsQ0FBMkI7QUFDbkRDLHFCQUFhLEtBQUs1QyxLQUFMLENBQVc0QztBQUQyQixPQUEzQixDQUExQjs7QUFJQSxVQUFNQywwQkFBMEIsS0FBS0MsOEJBQUwsQ0FBb0M7QUFDbEVDLHlCQUFpQixLQUFLL0MsS0FBTCxDQUFXK0MsZUFEc0M7QUFFbEU3RCxrQkFBVVUsTUFBTVYsUUFGa0Q7QUFHbEU4RCx5QkFBaUIsOEJBQWNwRCxLQUFkO0FBSGlELE9BQXBDLENBQWhDOztBQU1BLFVBQU1xRCxlQUFnQlosV0FBVztBQUFBO0FBQUE7QUFBV0E7QUFBWCxPQUFqQzs7QUFFQSxhQUNFO0FBQUE7QUFBQSxVQUFLLFdBQVUsdUJBQWY7QUFDRTtBQUFBO0FBQUEsWUFBTyxJQUFLekQsRUFBWixFQUFpQixXQUFZNkQsVUFBN0I7QUFDSVEsc0JBREo7QUFFRTtBQUNFLHFCQUFVbkIsT0FEWjtBQUVFLHVCQUFZbEMsTUFBTVEsU0FGcEI7QUFHRSx1QkFBWVIsTUFBTVMsU0FIcEI7QUFJRSxvQkFBUyxLQUFLTCxLQUFMLENBQVdrRCxNQUp0QjtBQUtFLHNCQUFXLEtBQUtsRCxLQUFMLENBQVdtRCxRQUx4QjtBQU1FLHVCQUFZTjtBQU5kLFlBRkY7QUFVRTtBQUNFLGtCQUFPLEtBQUs5QyxLQUFMLENBQVdoQixJQURwQjtBQUVFLHNCQUFXSixRQUZiO0FBR0UscUJBQVVtRCxPQUhaO0FBSUUscUJBQVUsS0FBS3NCLE9BQUwsRUFKWjtBQUtFLCtCQUFvQixLQUFLQyxpQkFBTCxFQUx0QjtBQU1FLDhCQUFtQmpCLGdCQU5yQjtBQU9FLHNCQUFXLEtBQUtwQyxLQUFMLENBQVdVLFFBQVgsSUFBdUIsRUFQcEM7QUFRRSx1QkFBWWdDLGlCQVJkO0FBU0UsNkJBQWtCOUMsTUFBTVYsUUFUMUI7QUFVRSxzQkFBV29ELFFBVmI7QUFXRSx3QkFBYUMsVUFYZjtBQVlFLHVCQUFZQztBQVpkO0FBVkY7QUFERixPQURGO0FBNkJEOzs7O0VBNUYwQiw4Qzs7QUErRjdCbkIsZUFBZWlDLFNBQWYsR0FBMkI7QUFDekIzRSxZQUFVLG9CQUFVNEUsTUFBVixDQUFpQkMsVUFERjtBQUV6QnpFLFFBQU0sb0JBQVUwRSxLQUFWLENBQWdCRCxVQUZHO0FBR3pCMUIsV0FBUyxvQkFBVTJCLEtBQVYsQ0FBZ0JELFVBSEE7QUFJekJqRCxVQUFRLG9CQUFVbUQsU0FBVixDQUFvQixDQUFDLG9CQUFVQyxJQUFYLEVBQWlCLG9CQUFVQyxLQUFWLENBQWdCO0FBQzNEcEQsZ0JBQVksb0JBQVVtRDtBQURxQyxHQUFoQixDQUFqQixDQUFwQixDQUppQjtBQU96Qi9ELFNBQU8sb0JBQVVpRSxNQVBRO0FBUXpCekIsb0JBQWtCLG9CQUFVc0IsU0FBVixDQUFvQixDQUFDLG9CQUFVSCxNQUFYLEVBQW1CLG9CQUFVdEYsSUFBN0IsQ0FBcEIsQ0FSTztBQVN6QitELFdBQVMsb0JBQVUyQixJQVRNO0FBVXpCekIsWUFBVSxvQkFBVXlCLElBVks7QUFXekIxQixTQUFPLG9CQUFVMEIsSUFYUTtBQVl6Qi9FLE1BQUksb0JBQVUyRSxNQVpXO0FBYXpCeEIsV0FBUyxvQkFBVXdCLE1BYk07QUFjekJwQixhQUFXLG9CQUFVd0IsSUFkSTtBQWV6QnRCLFdBQVMsb0JBQVVxQixTQUFWLENBQW9CLENBQzNCLG9CQUFVSSxJQURpQixFQUUzQixvQkFBVVAsTUFGaUIsQ0FBcEIsQ0FmZ0I7QUFtQnpCL0MsY0FBWSxvQkFBVXFELE1BbkJHO0FBb0J6QnhFLFVBQVEsb0JBQVV3RSxNQXBCTztBQXFCekJuRCxZQUFVLG9CQUFVbUQsTUFyQks7QUFzQnpCRSxhQUFXLG9CQUFVSCxLQUFWLENBQWdCO0FBQ3pCSSxVQUFNLG9CQUFVQyxLQUFWLENBQWdCLENBQUMsZ0JBQU05SSxpQkFBUCxFQUEwQixnQkFBTUMsbUJBQWhDLENBQWhCLEVBQXNFb0ksVUFEbkQ7QUFFekJVLG1CQUFlLG9CQUFVUCxJQUZBO0FBR3pCUSxpQkFBYSxvQkFBVVIsSUFIRTtBQUl6QlMsY0FBVSxvQkFBVW5HLElBSks7QUFLekJvRyxpQkFBYSxvQkFBVXBHLElBTEU7QUFNekJxRyxXQUFPLG9CQUFVWixTQUFWLENBQW9CLENBQUMsb0JBQVVHLE1BQVgsRUFBbUIsb0JBQVU1RixJQUE3QixDQUFwQixDQU5rQjtBQU96QjhELGFBQVMsb0JBQVUyQixTQUFWLENBQW9CLENBQUMsb0JBQVVILE1BQVgsRUFBbUIsb0JBQVV0RixJQUE3QixDQUFwQixDQVBnQjtBQVF6QnNHLG1CQUFlLG9CQUFVZCxLQVJBO0FBU3pCZSxhQUFTLG9CQUFVZCxTQUFWLENBQW9CLENBQUMsb0JBQVVILE1BQVgsRUFBbUIsb0JBQVV0RixJQUE3QixDQUFwQixDQVRnQjtBQVV6QndHLHNCQUFrQixvQkFBVWQ7QUFWSCxHQUFoQixDQXRCYztBQWtDekJmLGVBQWEsb0JBQVUzRSxJQWxDRTtBQW1DekI4RSxtQkFBaUIsb0JBQVU5RSxJQW5DRjtBQW9DekJxRSxZQUFVLG9CQUFVb0IsU0FBVixDQUFvQixDQUFDLG9CQUFVRyxNQUFYLEVBQW1CLG9CQUFVNUYsSUFBN0IsQ0FBcEIsQ0FwQ2U7QUFxQ3pCdUUsYUFBVyxvQkFBVXFCLE1BckNJO0FBc0N6QnRCLGNBQVksb0JBQVVtQixTQUFWLENBQW9CLENBQUMsb0JBQVVILE1BQVgsRUFBbUIsb0JBQVV0RixJQUE3QixDQUFwQixDQXRDYTtBQXVDekJ5RyxpQkFBZSxvQkFBVUMsT0FBVixDQUFrQixvQkFBVWYsS0FBVixDQUFnQjtBQUMvQzFDLGVBQVcsb0JBQVVxQyxNQUFWLENBQWlCQyxVQURtQjtBQUUvQ29CLFdBQU8sb0JBQVVYLEtBQVYsQ0FBZ0IsQ0FBQyxnQkFBTS9JLFNBQVAsRUFBa0IsZ0JBQU1ELFFBQXhCLENBQWhCLEVBQW1EdUk7QUFGWCxHQUFoQixDQUFsQixDQXZDVTtBQTJDekJxQix3QkFBc0Isb0JBQVVaLEtBQVYsQ0FBZ0IsQ0FBQyxnQkFBTS9JLFNBQVAsRUFBa0IsZ0JBQU1ELFFBQXhCLENBQWhCLENBM0NHO0FBNEN6QnlHLFdBQVMsb0JBQVV6RCxJQTVDTTtBQTZDekIwQyxpQkFBZSxvQkFBVTFDLElBN0NBO0FBOEN6QmlGLFVBQVEsb0JBQVVqRixJQTlDTztBQStDekJrRixZQUFVLG9CQUFVbEY7QUEvQ0ssQ0FBM0I7O0FBa0RBb0QsZUFBZXlELFlBQWYsR0FBOEI7QUFDNUJ2RSxVQUFRLEtBRG9CO0FBRTVCeUIsV0FBUyxLQUZtQjtBQUc1QkUsWUFBVSxJQUhrQjtBQUk1QkQsU0FBTyxLQUpxQjtBQUs1QkUsYUFBVyxLQUxpQjtBQU01QkMsb0JBQWtCO0FBTlUsQ0FBOUI7O2tCQVNlZixjOzs7Ozs7O0FDdktmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDMURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBLDJCOzs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FDWkE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTTBELFNBQVMsU0FBVEEsTUFBUyxDQUFDL0UsS0FBRCxFQUFXO0FBQUEsTUFDaEIzRSxtQkFEZ0IsbUJBQ2hCQSxtQkFEZ0I7QUFBQSxNQUl0QnlHLE9BSnNCLEdBVXBCOUIsS0FWb0IsQ0FJdEI4QixPQUpzQjtBQUFBLE1BS3RCb0IsTUFMc0IsR0FVcEJsRCxLQVZvQixDQUt0QmtELE1BTHNCO0FBQUEsTUFNdEJDLFFBTnNCLEdBVXBCbkQsS0FWb0IsQ0FNdEJtRCxRQU5zQjtBQUFBLE1BT3RCL0MsU0FQc0IsR0FVcEJKLEtBVm9CLENBT3RCSSxTQVBzQjtBQUFBLE1BUXRCQyxTQVJzQixHQVVwQkwsS0FWb0IsQ0FRdEJLLFNBUnNCO0FBQUEsTUFTdEIwRCxTQVRzQixHQVVwQi9ELEtBVm9CLENBU3RCK0QsU0FUc0I7OztBQVl4QixTQUNFO0FBQUE7QUFBQTtBQUNFO0FBQUE7QUFBQTtBQUVLQSxnQkFBVUMsSUFBVixLQUFtQjNJLG1CQUFuQixJQUEwQyxDQUFDMEksVUFBVVUsZ0JBQXRELEdBQ0ksNkRBQTBCVixTQUExQixDQURKLEdBQytDLElBSG5EO0FBTUlqQyxjQUFRckMsR0FBUixDQUFZLFVBQUN1RixNQUFELEVBQVN2SCxDQUFULEVBQWU7QUFDekIsWUFBSSxDQUFDdUgsT0FBT0MsTUFBWixFQUFvQjtBQUNsQixjQUFNQyxXQUFXRixPQUFPOUQsU0FBUCxLQUFxQmQsU0FBdEM7QUFDQSxjQUFNK0UsZ0JBQWdCSCxPQUFPOUQsU0FBUCxLQUFxQmQsU0FBM0M7O0FBRUEsaUJBQ0U7QUFDRSxtQkFBUTNDLENBRFY7QUFFRSxpQkFBTXVILE9BQU85RCxTQUZmO0FBR0Usb0JBQVM4RCxNQUhYO0FBSUUsb0JBQVM5QixNQUpYO0FBS0UscUJBQVVnQyxRQUxaO0FBTUUsc0JBQVcvQixRQU5iO0FBT0UsdUJBQVk5QyxTQVBkO0FBUUUsMkJBQWdCOEU7QUFSbEIsWUFERjtBQVdEO0FBQ0QsZUFBTyxLQUFQO0FBQ0QsT0FsQkQ7QUFOSjtBQURGLEdBREY7QUErQkQsQ0EzQ0QsQyxDQVJBOzs7QUFxREFKLE9BQU96QixTQUFQLEdBQW1CO0FBQ2pCeEIsV0FBUyxvQkFBVTJCLEtBQVYsQ0FBZ0JELFVBRFI7QUFFakJOLFVBQVEsb0JBQVVqRixJQUZEO0FBR2pCa0YsWUFBVSxvQkFBVWxGLElBSEg7QUFJakJtQyxhQUFXLG9CQUFVbUQsTUFKSjtBQUtqQmxELGFBQVcsb0JBQVVrRCxNQUxKO0FBTWpCUSxhQUFXLG9CQUFVRjtBQU5KLENBQW5COztrQkFTZWtCLE07Ozs7Ozs7Ozs7Ozs7a1FDOURmOzs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBR0EsSUFBTUssYUFBYSxTQUFiQSxVQUFhLENBQUNwRixLQUFELEVBQVc7QUFBQSxNQUUxQmdGLE1BRjBCLEdBU3hCaEYsS0FUd0IsQ0FFMUJnRixNQUYwQjtBQUFBLE1BRzFCSyxLQUgwQixHQVN4QnJGLEtBVHdCLENBRzFCcUYsS0FIMEI7QUFBQSxNQUkxQm5DLE1BSjBCLEdBU3hCbEQsS0FUd0IsQ0FJMUJrRCxNQUowQjtBQUFBLE1BSzFCb0MsT0FMMEIsR0FTeEJ0RixLQVR3QixDQUsxQnNGLE9BTDBCO0FBQUEsTUFNMUJqRixTQU4wQixHQVN4QkwsS0FUd0IsQ0FNMUJLLFNBTjBCO0FBQUEsTUFPMUI4RSxhQVAwQixHQVN4Qm5GLEtBVHdCLENBTzFCbUYsYUFQMEI7QUFBQSxNQVExQmhDLFFBUjBCLEdBU3hCbkQsS0FUd0IsQ0FRMUJtRCxRQVIwQjtBQUFBLE1BWTFCb0MsSUFaMEIsR0F3QnhCUCxNQXhCd0IsQ0FZMUJPLElBWjBCO0FBQUEsTUFhMUI5RSxJQWIwQixHQXdCeEJ1RSxNQXhCd0IsQ0FhMUJ2RSxJQWIwQjtBQUFBLE1BYzFCcEIsTUFkMEIsR0F3QnhCMkYsTUF4QndCLENBYzFCM0YsTUFkMEI7QUFBQSxNQWUxQm1HLFdBZjBCLEdBd0J4QlIsTUF4QndCLENBZTFCUSxXQWYwQjtBQUFBLE1BZ0IxQkMsV0FoQjBCLEdBd0J4QlQsTUF4QndCLENBZ0IxQlMsV0FoQjBCO0FBQUEsTUFpQjFCQyxlQWpCMEIsR0F3QnhCVixNQXhCd0IsQ0FpQjFCVSxlQWpCMEI7QUFBQSxNQWtCMUJDLFlBbEIwQixHQXdCeEJYLE1BeEJ3QixDQWtCMUJXLFlBbEIwQjtBQUFBLE1BbUIxQkMsYUFuQjBCLEdBd0J4QlosTUF4QndCLENBbUIxQlksYUFuQjBCO0FBQUEsTUFvQjFCQyxXQXBCMEIsR0F3QnhCYixNQXhCd0IsQ0FvQjFCYSxXQXBCMEI7QUFBQSxNQXFCMUJDLFdBckIwQixHQXdCeEJkLE1BeEJ3QixDQXFCMUJjLFdBckIwQjtBQUFBLE1Bc0IxQkMsb0JBdEIwQixHQXdCeEJmLE1BeEJ3QixDQXNCMUJlLG9CQXRCMEI7QUFBQSxNQXVCMUJDLGtCQXZCMEIsR0F3QnhCaEIsTUF4QndCLENBdUIxQmdCLGtCQXZCMEI7OztBQTBCNUIsTUFBTUMseUJBQ0QsZ0JBQUVsSixVQUFGLENBQWErSSxXQUFiLElBQTRCQSxZQUFZZCxNQUFaLEVBQW9CSyxLQUFwQixDQUE1QixHQUF5RFMsV0FEeEQsRUFFREgsWUFGQyxDQUFOOztBQUtBLE1BQUlPLG1CQUFKO0FBQ0EsTUFBSUMsa0JBQUo7QUFDQSxNQUFJQyxZQUFZLEVBQWhCO0FBQ0EsTUFBSUMsY0FBYyxnQkFBRXRKLFVBQUYsQ0FBYTZJLGFBQWIsSUFBOEJBLGNBQWNaLE1BQWQsRUFBc0JLLEtBQXRCLENBQTlCLEdBQTZETyxhQUEvRTs7QUFFQSxNQUFJQyxXQUFKLEVBQWlCO0FBQ2ZPLGdCQUFZLGdCQUFFckosVUFBRixDQUFhOEksV0FBYixJQUE0QkEsWUFBWWIsTUFBWixFQUFvQkssS0FBcEIsQ0FBNUIsR0FBeURRLFdBQXJFO0FBQ0Q7O0FBRUQsTUFBSUwsV0FBSixFQUFpQjtBQUNmUyxjQUFVSyxLQUFWLEdBQWtCLGdCQUFFdkosVUFBRixDQUFheUksV0FBYixJQUE0QkEsWUFBWVIsTUFBWixFQUFvQkssS0FBcEIsQ0FBNUIsR0FBeURFLElBQTNFO0FBQ0Q7O0FBRUQsTUFBSUUsV0FBSixFQUFpQjtBQUNmVyxjQUFVRyxTQUFWLEdBQXNCLGdCQUFFeEosVUFBRixDQUFhMEksV0FBYixJQUE0QkEsWUFBWVQsTUFBWixFQUFvQkssS0FBcEIsQ0FBNUIsR0FBeURJLFdBQS9FO0FBQ0Q7O0FBRUQsTUFBSWhGLElBQUosRUFBVTtBQUNSLFFBQU0rRixjQUFjUCxVQUFVUSxPQUE5QjtBQUNBUixjQUFVUSxPQUFWLEdBQW9CLFVBQUNuSyxDQUFELEVBQU87QUFDekI0RyxhQUFPOEIsTUFBUDtBQUNBLFVBQUksZ0JBQUVqSSxVQUFGLENBQWF5SixXQUFiLENBQUosRUFBK0JBLFlBQVlsSyxDQUFaO0FBQ2hDLEtBSEQ7QUFJQTJKLGNBQVVTLFNBQVYsR0FBc0IsMEJBQUdULFVBQVVTLFNBQWIsRUFBd0IsVUFBeEIsQ0FBdEI7O0FBRUEsUUFBSXBCLE9BQUosRUFBYTtBQUNYWSxtQkFBYSxpREFBVyxPQUFRN0YsU0FBbkIsR0FBYjs7QUFFQTtBQUNBZ0csb0JBQWMsMEJBQ1pBLFdBRFksRUFFWixnQkFBRXRKLFVBQUYsQ0FBYWdKLG9CQUFiLElBQ0lBLHFCQUFxQmYsTUFBckIsRUFBNkIzRSxTQUE3QixFQUF3QzhFLGFBQXhDLEVBQXVERSxLQUF2RCxDQURKLEdBRUlVLG9CQUpRLENBQWQ7O0FBT0FLLCtCQUNLQSxTQURMLEVBRUssZ0JBQUVySixVQUFGLENBQWFpSixrQkFBYixJQUNDQSxtQkFBbUJoQixNQUFuQixFQUEyQjNFLFNBQTNCLEVBQXNDOEUsYUFBdEMsRUFBcURFLEtBQXJELENBREQsR0FFQ1csa0JBSk47QUFNRCxLQWpCRCxNQWlCTztBQUNMRSxtQkFBYSxxREFBYjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSUcsV0FBSixFQUFpQkosVUFBVVMsU0FBVixHQUFzQiwwQkFBR1QsVUFBVVMsU0FBYixFQUF3QkwsV0FBeEIsQ0FBdEI7QUFDakIsTUFBSSxDQUFDLGdCQUFFaEosYUFBRixDQUFnQitJLFNBQWhCLENBQUwsRUFBaUNILFVBQVUzQixLQUFWLEdBQWtCOEIsU0FBbEI7QUFDakMsTUFBSS9HLE1BQUosRUFBWTtBQUNWOEcsZ0JBQVksOEJBQUMsTUFBRCxDQUFRLE1BQVIsZUFBb0I5RyxPQUFPVyxLQUEzQixJQUFtQyxVQUFXbUQsUUFBOUMsRUFBeUQsUUFBUzZCLE1BQWxFLElBQVo7QUFDRDs7QUFFRCxNQUFNMkIsV0FBV2pCLGtCQUNmQSxnQkFBZ0JWLE1BQWhCLEVBQXdCSyxLQUF4QixFQUErQixFQUFFdUIsYUFBYVYsVUFBZixFQUEyQlcsZUFBZVYsU0FBMUMsRUFBL0IsQ0FEZSxHQUVmWixJQUZGOztBQUlBLE1BQUlHLGVBQUosRUFBcUI7QUFDbkIsV0FBTyxnQkFBTW9CLGFBQU4sQ0FBb0IsSUFBcEIsRUFBMEJiLFNBQTFCLEVBQXFDVSxRQUFyQyxDQUFQO0FBQ0Q7O0FBRUQsU0FBTyxnQkFBTUcsYUFBTixDQUFvQixJQUFwQixFQUEwQmIsU0FBMUIsRUFBcUNVLFFBQXJDLEVBQStDVCxVQUEvQyxFQUEyREMsU0FBM0QsQ0FBUDtBQUNELENBN0ZEOztBQStGQWYsV0FBVzlCLFNBQVgsR0FBdUI7QUFDckIwQixVQUFRLG9CQUFVcEIsS0FBVixDQUFnQjtBQUN0QjFDLGVBQVcsb0JBQVVxQyxNQUFWLENBQWlCQyxVQUROO0FBRXRCK0IsVUFBTSxvQkFBVWhDLE1BQVYsQ0FBaUJDLFVBRkQ7QUFHdEJ5QixZQUFRLG9CQUFVdEIsSUFISTtBQUl0QitCLHFCQUFpQixvQkFBVXpILElBSkw7QUFLdEI4SSxlQUFXLG9CQUFVOUksSUFMQztBQU10QitJLHFCQUFpQixvQkFBVUMsR0FOTDtBQU90QnJCLG1CQUFlLG9CQUFVbEMsU0FBVixDQUFvQixDQUFDLG9CQUFVSCxNQUFYLEVBQW1CLG9CQUFVdEYsSUFBN0IsQ0FBcEIsQ0FQTztBQVF0QjhELGFBQVMsb0JBQVUyQixTQUFWLENBQW9CLENBQUMsb0JBQVVILE1BQVgsRUFBbUIsb0JBQVV0RixJQUE3QixDQUFwQixDQVJhO0FBU3RCNEgsaUJBQWEsb0JBQVVuQyxTQUFWLENBQW9CLENBQUMsb0JBQVVHLE1BQVgsRUFBbUIsb0JBQVU1RixJQUE3QixDQUFwQixDQVRTO0FBVXRCcUcsV0FBTyxvQkFBVVosU0FBVixDQUFvQixDQUFDLG9CQUFVRyxNQUFYLEVBQW1CLG9CQUFVNUYsSUFBN0IsQ0FBcEIsQ0FWZTtBQVd0QnVILGlCQUFhLG9CQUFVOUIsU0FBVixDQUFvQixDQUFDLG9CQUFVQyxJQUFYLEVBQWlCLG9CQUFVMUYsSUFBM0IsQ0FBcEIsQ0FYUztBQVl0QnFJLFdBQU8sb0JBQVU1QyxTQUFWLENBQW9CLENBQUMsb0JBQVVDLElBQVgsRUFBaUIsb0JBQVUxRixJQUEzQixDQUFwQixDQVplO0FBYXRCMEgsa0JBQWMsb0JBQVU5QixNQWJGO0FBY3RCcUQsWUFBUSxvQkFBVXJELE1BZEk7QUFldEI0QixpQkFBYSxvQkFBVS9CLFNBQVYsQ0FBb0IsQ0FBQyxvQkFBVUgsTUFBWCxFQUFtQixvQkFBVXRGLElBQTdCLENBQXBCLENBZlM7QUFnQnRCa0osV0FBTyxvQkFBVXpELFNBQVYsQ0FBb0IsQ0FBQyxvQkFBVUgsTUFBWCxFQUFtQixvQkFBVXRGLElBQTdCLENBQXBCLENBaEJlO0FBaUJ0QjZILGlCQUFhLG9CQUFVcEMsU0FBVixDQUFvQixDQUFDLG9CQUFVRyxNQUFYLEVBQW1CLG9CQUFVNUYsSUFBN0IsQ0FBcEIsQ0FqQlM7QUFrQnRCbUosV0FBTyxvQkFBVTFELFNBQVYsQ0FBb0IsQ0FBQyxvQkFBVUcsTUFBWCxFQUFtQixvQkFBVTVGLElBQTdCLENBQXBCLENBbEJlO0FBbUJ0QndDLFVBQU0sb0JBQVVrRCxJQW5CTTtBQW9CdEIwRCxjQUFVLG9CQUFVcEosSUFwQkU7QUFxQnRCaUYsWUFBUSxvQkFBVWpGLElBckJJO0FBc0J0QnFKLGNBQVUsb0JBQVU1RCxTQUFWLENBQW9CLENBQUMsb0JBQVVDLElBQVgsRUFBaUIsb0JBQVUxRixJQUEzQixDQUFwQixDQXRCWTtBQXVCdEJzSixtQkFBZSxvQkFBVTdELFNBQVYsQ0FBb0IsQ0FBQyxvQkFBVUcsTUFBWCxFQUFtQixvQkFBVTVGLElBQTdCLENBQXBCLENBdkJPO0FBd0J0QnVKLHFCQUFpQixvQkFBVTlELFNBQVYsQ0FBb0IsQ0FBQyxvQkFBVUgsTUFBWCxFQUFtQixvQkFBVXRGLElBQTdCLENBQXBCLENBeEJLO0FBeUJ0QndKLGlCQUFhLG9CQUFVL0QsU0FBVixDQUFvQixDQUFDLG9CQUFVRyxNQUFYLEVBQW1CLG9CQUFVNUYsSUFBN0IsQ0FBcEIsQ0F6QlM7QUEwQnRCeUosbUJBQWUsb0JBQVVoRSxTQUFWLENBQW9CLENBQUMsb0JBQVVILE1BQVgsRUFBbUIsb0JBQVV0RixJQUE3QixDQUFwQixDQTFCTztBQTJCdEIwSixlQUFXLG9CQUFVMUosSUEzQkM7QUE0QnRCb0IsWUFBUSxvQkFBVXdFLE1BNUJJO0FBNkJ0QitELGlCQUFhLG9CQUFVM0o7QUE3QkQsR0FBaEIsRUE4Qkx1RixVQS9Ca0I7QUFnQ3JCNkIsU0FBTyxvQkFBVXdDLE1BQVYsQ0FBaUJyRSxVQWhDSDtBQWlDckJOLFVBQVEsb0JBQVVqRixJQWpDRztBQWtDckJxSCxXQUFTLG9CQUFVM0IsSUFsQ0U7QUFtQ3JCdEQsYUFBVyxvQkFBVTRELEtBQVYsQ0FBZ0IsQ0FBQyxnQkFBTWhKLFFBQVAsRUFBaUIsZ0JBQU1DLFNBQXZCLENBQWhCLENBbkNVO0FBb0NyQmlLLGlCQUFlLG9CQUFVeEIsSUFwQ0o7QUFxQ3JCUixZQUFVLG9CQUFVbEY7QUFyQ0MsQ0FBdkI7O2tCQXdDZW1ILFU7Ozs7Ozs7Ozs7Ozs7QUNsSmY7Ozs7OztBQUVBLElBQU0wQyxhQUFhLFNBQWJBLFVBQWE7QUFBQSxTQUNqQjtBQUFBO0FBQUEsTUFBTSxXQUFVLE9BQWhCO0FBQ0U7QUFBQTtBQUFBLFFBQU0sV0FBVSxVQUFoQjtBQUNFLDhDQUFNLFdBQVUsT0FBaEI7QUFERixLQURGO0FBSUU7QUFBQTtBQUFBLFFBQU0sV0FBVSxRQUFoQjtBQUNFLDhDQUFNLFdBQVUsT0FBaEI7QUFERjtBQUpGLEdBRGlCO0FBQUEsQ0FBbkI7O2tCQVVlQSxVOzs7Ozs7Ozs7Ozs7O0FDWmY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7OztBQUVBLElBQU1DLFlBQVksU0FBWkEsU0FBWSxPQUFlO0FBQUEsTUFBWm5ELEtBQVksUUFBWkEsS0FBWTs7QUFDL0IsTUFBTW9ELGFBQWEsMEJBQUcsa0NBQUgsRUFBdUM7QUFDeERDLFlBQVFyRCxVQUFVLGdCQUFNM0o7QUFEZ0MsR0FBdkMsQ0FBbkI7QUFHQSxTQUNFO0FBQUE7QUFBQSxNQUFNLFdBQVkrTSxVQUFsQjtBQUNFLDRDQUFNLFdBQVUsT0FBaEI7QUFERixHQURGO0FBS0QsQ0FURDs7QUFXQUQsVUFBVXpFLFNBQVYsR0FBc0I7QUFDcEJzQixTQUFPLG9CQUFVWCxLQUFWLENBQWdCLENBQUMsZ0JBQU1oSixRQUFQLEVBQWlCLGdCQUFNQyxTQUF2QixDQUFoQixFQUFtRHNJO0FBRHRDLENBQXRCO2tCQUdldUUsUzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkJmOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFIQTs7O0FBS08sSUFBTUcsOEJBQVcsU0FBWEEsUUFBVztBQUFBLE1BQUdDLE9BQUgsUUFBR0EsT0FBSDtBQUFBLE1BQVlDLGFBQVosUUFBWUEsYUFBWjtBQUFBLFNBQ3RCO0FBQ0UsVUFBSyxVQURQO0FBRUUsYUFBVUQsT0FGWjtBQUdFLFNBQU0sYUFBQ0UsS0FBRCxFQUFXO0FBQ2YsVUFBSUEsS0FBSixFQUFXQSxNQUFNRCxhQUFOLEdBQXNCQSxhQUF0QixDQURJLENBQ2lDO0FBQ2pEO0FBTEgsSUFEc0I7QUFBQSxDQUFqQjs7QUFVUEYsU0FBUzVFLFNBQVQsR0FBcUI7QUFDbkI2RSxXQUFTLG9CQUFVeEUsSUFBVixDQUFlSCxVQURMO0FBRW5CNEUsaUJBQWUsb0JBQVV6RSxJQUFWLENBQWVIO0FBRlgsQ0FBckI7O0lBS3FCOEUsbUI7OztBQU9uQixpQ0FBYztBQUFBOztBQUFBOztBQUVaLFVBQUtDLG1CQUFMLEdBQTJCLE1BQUtBLG1CQUFMLENBQXlCQyxJQUF6QixPQUEzQjtBQUZZO0FBR2I7O0FBRUQ7Ozs7Ozs7OzswQ0FLc0JqSCxTLEVBQVc7QUFBQSxVQUN2QnBHLGlCQUR1QixtQkFDdkJBLGlCQUR1QjtBQUFBLG1CQUVDLEtBQUs2RSxLQUZOO0FBQUEsVUFFdkJnRSxJQUZ1QixVQUV2QkEsSUFGdUI7QUFBQSxVQUVqQnlFLGFBRmlCLFVBRWpCQSxhQUZpQjs7O0FBSS9CLFVBQUl6RSxTQUFTN0ksaUJBQWIsRUFBZ0MsT0FBTyxLQUFQOztBQUVoQyxhQUFPb0csVUFBVWtILGFBQVYsS0FBNEJBLGFBQW5DO0FBQ0Q7Ozt3Q0FFbUJuTSxDLEVBQUc7QUFBQSxVQUNieUcsZUFEYSxHQUNPLEtBQUsvQyxLQURaLENBQ2IrQyxlQURhOzs7QUFHckJBLHNCQUFnQnpHLENBQWhCO0FBQ0Q7Ozs2QkFFUTtBQUFBLFVBRUxoQix1QkFGSyxtQkFFTEEsdUJBRks7QUFBQSxVQUVvQkMsNkJBRnBCLG1CQUVvQkEsNkJBRnBCO0FBQUEsVUFFbURKLGlCQUZuRCxtQkFFbURBLGlCQUZuRDtBQUFBLG9CQUt5QixLQUFLNkUsS0FMOUI7QUFBQSxVQUtDZ0UsSUFMRCxXQUtDQSxJQUxEO0FBQUEsVUFLT3lFLGFBTFAsV0FLT0EsYUFMUDs7O0FBT1AsVUFBTU4sVUFBVU0sa0JBQWtCbk4sdUJBQWxDOztBQUVBLFVBQU04TSxnQkFBZ0JLLGtCQUFrQmxOLDZCQUF4Qzs7QUFFQSxhQUFPeUksU0FBUzdJLGlCQUFULEdBQ0gsc0NBQUksMEJBQUosR0FERyxHQUdIO0FBQUE7QUFBQSxVQUFJLDBCQUFKLEVBQXVCLFNBQVUsS0FBS29OLG1CQUF0QztBQUNFLHNDQUFDLFFBQUQsZUFDTyxLQUFLdkksS0FEWjtBQUVFLG1CQUFVbUksT0FGWjtBQUdFLHlCQUFnQkM7QUFIbEI7QUFERixPQUhKO0FBV0Q7Ozs7OztBQXREa0JFLG1CLENBQ1poRixTLEdBQVk7QUFDakJVLFFBQU0sb0JBQVVULE1BQVYsQ0FBaUJDLFVBRE47QUFFakJpRixpQkFBZSxvQkFBVWxGLE1BRlI7QUFHakJSLG1CQUFpQixvQkFBVTlFO0FBSFYsQztrQkFEQXFLLG1COzs7Ozs7Ozs7Ozs7O0FDbkJyQjs7OztBQUNBOzs7Ozs7QUFGQTtBQUlBLElBQU1JLFVBQVUsU0FBVkEsT0FBVSxDQUFDMUksS0FBRCxFQUFXO0FBQ3pCLE1BQUksQ0FBQ0EsTUFBTTJHLFFBQVgsRUFBcUIsT0FBTyxJQUFQO0FBQ3JCLFNBQ0U7QUFBQTtBQUFBO0FBQVczRyxVQUFNMkc7QUFBakIsR0FERjtBQUdELENBTEQ7O0FBT0ErQixRQUFRcEYsU0FBUixHQUFvQjtBQUNsQnFELFlBQVUsb0JBQVVqRCxTQUFWLENBQW9CLENBQzVCLG9CQUFVSSxJQURrQixFQUU1QixvQkFBVVAsTUFGa0IsQ0FBcEI7QUFEUSxDQUFwQjs7a0JBT2VtRixPOzs7Ozs7Ozs7Ozs7O2tRQ2xCZjtBQUNBOztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNQyxPQUFPLFNBQVBBLElBQU8sQ0FBQzNJLEtBQUQsRUFBVztBQUFBLE1BRXBCOEIsT0FGb0IsR0FjbEI5QixLQWRrQixDQUVwQjhCLE9BRm9CO0FBQUEsTUFHcEIvQyxJQUhvQixHQWNsQmlCLEtBZGtCLENBR3BCakIsSUFIb0I7QUFBQSxNQUlwQkosUUFKb0IsR0FjbEJxQixLQWRrQixDQUlwQnJCLFFBSm9CO0FBQUEsTUFLcEJ5RSxPQUxvQixHQWNsQnBELEtBZGtCLENBS3BCb0QsT0FMb0I7QUFBQSxNQU1wQmhCLGdCQU5vQixHQWNsQnBDLEtBZGtCLENBTXBCb0MsZ0JBTm9CO0FBQUEsTUFPcEJpQixpQkFQb0IsR0FjbEJyRCxLQWRrQixDQU9wQnFELGlCQVBvQjtBQUFBLE1BUXBCM0MsUUFSb0IsR0FjbEJWLEtBZGtCLENBUXBCVSxRQVJvQjtBQUFBLE1BU3BCcUQsU0FUb0IsR0FjbEIvRCxLQWRrQixDQVNwQitELFNBVG9CO0FBQUEsTUFVcEI2RSxlQVZvQixHQWNsQjVJLEtBZGtCLENBVXBCNEksZUFWb0I7QUFBQSxNQVdwQnRHLFFBWG9CLEdBY2xCdEMsS0Fka0IsQ0FXcEJzQyxRQVhvQjtBQUFBLE1BWXBCQyxVQVpvQixHQWNsQnZDLEtBZGtCLENBWXBCdUMsVUFab0I7QUFBQSxNQWFwQkMsU0Fib0IsR0FjbEJ4QyxLQWRrQixDQWFwQndDLFNBYm9CO0FBQUEsTUFpQnBCZ0MsT0FqQm9CLEdBbUJsQlQsU0FuQmtCLENBaUJwQlMsT0FqQm9CO0FBQUEsTUFrQnBCRCxhQWxCb0IsR0FtQmxCUixTQW5Ca0IsQ0FrQnBCUSxhQWxCb0I7OztBQXFCdEIsTUFBSXNFLGdCQUFKOztBQUVBLE1BQUl6RixPQUFKLEVBQWE7QUFDWCxRQUFNMEYsYUFBYSxnQkFBRS9MLFVBQUYsQ0FBYXFGLGdCQUFiLElBQWlDQSxrQkFBakMsR0FBc0RBLGdCQUF6RTtBQUNBLFFBQUksQ0FBQzBHLFVBQUwsRUFBaUI7QUFDZixhQUFPLElBQVA7QUFDRDtBQUNERCxjQUFVLHNEQUFZLFNBQVVDLFVBQXRCLEVBQW1DLFNBQVV6RixpQkFBN0MsR0FBVjtBQUNELEdBTkQsTUFNTztBQUNMLFFBQU0wRixrQkFBa0JySSxTQUFTcUksZUFBVCxJQUE0QixFQUFwRDtBQUNBRixjQUFVOUosS0FBS1UsR0FBTCxDQUFTLFVBQUNaLEdBQUQsRUFBTXdHLEtBQU4sRUFBZ0I7QUFDakMsVUFBTTJELE1BQU0sZ0JBQUVsTixHQUFGLENBQU0rQyxHQUFOLEVBQVdGLFFBQVgsQ0FBWjtBQUNBLFVBQU0ySSxXQUFXLEVBQUV5QixnQkFBZ0JqTSxNQUFoQixHQUF5QixDQUF6QixJQUE4QmlNLGdCQUFnQkUsT0FBaEIsQ0FBd0JELEdBQXhCLElBQStCLENBQUMsQ0FBaEUsQ0FBakI7O0FBRUEsVUFBTTlKLFdBQVc2RSxVQUFVQyxJQUFWLEtBQW1CLGdCQUFNM0ksbUJBQXpCLEdBQ2J1TixnQkFBZ0J0SixRQUFoQixDQUF5QjBKLEdBQXpCLENBRGEsR0FFYixJQUZKOztBQUlBLFVBQU01QixRQUFRNUUsYUFBYSxFQUEzQjtBQUNBLFVBQUk4QixRQUFRLGdCQUFFdkgsVUFBRixDQUFhdUYsUUFBYixJQUF5QkEsU0FBU3pELEdBQVQsRUFBY3dHLEtBQWQsQ0FBekIsR0FBZ0QvQyxRQUE1RDtBQUNBLFVBQUlQLFVBQVcsZ0JBQUVoRixVQUFGLENBQWF3RixVQUFiLElBQTJCQSxXQUFXMUQsR0FBWCxFQUFnQndHLEtBQWhCLENBQTNCLEdBQW9EOUMsVUFBbkU7QUFDQSxVQUFJckQsUUFBSixFQUFjO0FBQ1osWUFBTWdLLGdCQUFnQixnQkFBRW5NLFVBQUYsQ0FBYWdILFVBQVVPLEtBQXZCLElBQ2xCUCxVQUFVTyxLQUFWLENBQWdCekYsR0FBaEIsRUFBcUJ3RyxLQUFyQixDQURrQixHQUVsQnRCLFVBQVVPLEtBRmQ7O0FBSUEsWUFBTTZFLGtCQUFrQixnQkFBRXBNLFVBQUYsQ0FBYWdILFVBQVVoQyxPQUF2QixJQUNwQmdDLFVBQVVoQyxPQUFWLENBQWtCbEQsR0FBbEIsRUFBdUJ3RyxLQUF2QixDQURvQixHQUVwQnRCLFVBQVVoQyxPQUZkOztBQUlBdUMsNkJBQ0tBLEtBREwsRUFFSzRFLGFBRkw7QUFJQW5ILGtCQUFVLDBCQUFHQSxPQUFILEVBQVlvSCxlQUFaLENBQVY7O0FBRUEsWUFBSTNFLE9BQUosRUFBYTtBQUNYRixrQkFBUUEsU0FBUyxFQUFqQjtBQUNBQSxnQkFBTThFLGVBQU4sR0FBd0IsZ0JBQUVyTSxVQUFGLENBQWF5SCxPQUFiLElBQXdCQSxRQUFRM0YsR0FBUixFQUFhd0csS0FBYixDQUF4QixHQUE4Q2IsT0FBdEU7QUFDRDtBQUNGOztBQUVELFVBQU02RSxhQUFhLENBQUM5RSxhQUFELElBQWtCLENBQUNBLGNBQWNqRixRQUFkLENBQXVCMEosR0FBdkIsQ0FBdEM7O0FBRUEsYUFDRTtBQUNFLGFBQU1BLEdBRFI7QUFFRSxhQUFNbkssR0FGUjtBQUdFLGtCQUFXRixRQUhiO0FBSUUsa0JBQVcwRyxLQUpiO0FBS0UsaUJBQVV2RCxPQUxaO0FBTUUsa0JBQVdwQixRQU5iO0FBT0Usa0JBQVc0RyxRQVBiO0FBUUUsb0JBQWErQixVQVJmO0FBU0Usa0JBQVduSyxRQVRiO0FBVUUsbUJBQVk2RSxTQVZkO0FBV0UsZUFBUU8sS0FYVjtBQVlFLG1CQUFZdkMsT0FaZDtBQWFFLGVBQVFxRjtBQWJWLFFBREY7QUFpQkQsS0FuRFMsQ0FBVjtBQW9ERDs7QUFFRCxTQUNFO0FBQUE7QUFBQTtBQUFTeUI7QUFBVCxHQURGO0FBR0QsQ0F4RkQ7O0FBMEZBRixLQUFLckYsU0FBTCxHQUFpQjtBQUNmM0UsWUFBVSxvQkFBVTRFLE1BQVYsQ0FBaUJDLFVBRFo7QUFFZnpFLFFBQU0sb0JBQVUwRSxLQUFWLENBQWdCRCxVQUZQO0FBR2YxQixXQUFTLG9CQUFVMkIsS0FBVixDQUFnQkQsVUFIVjtBQUlmTyxhQUFXLG9CQUFVRixNQUpOO0FBS2YrRSxtQkFBaUIsb0JBQVVuRjtBQUxaLENBQWpCOztrQkFRZWtGLEk7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUdmOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7K2VBVEE7QUFDQTs7O0lBVU1XLEc7Ozs7Ozs7Ozs7OzZCQUNLO0FBQUEsbUJBY0gsS0FBS3RKLEtBZEY7QUFBQSxVQUVMbkIsR0FGSyxVQUVMQSxHQUZLO0FBQUEsVUFHTGlELE9BSEssVUFHTEEsT0FISztBQUFBLFVBSUxuRCxRQUpLLFVBSUxBLFFBSks7QUFBQSxVQUtMNEssUUFMSyxVQUtMQSxRQUxLO0FBQUEsVUFNTDdDLFNBTkssVUFNTEEsU0FOSztBQUFBLFVBT0xwQyxLQVBLLFVBT0xBLEtBUEs7QUFBQSxVQVFMOEMsS0FSSyxVQVFMQSxLQVJLO0FBQUEsVUFTTDFHLFFBVEssVUFTTEEsUUFUSztBQUFBLFVBVUx4QixRQVZLLFVBVUxBLFFBVks7QUFBQSxVQVdMNkUsU0FYSyxVQVdMQSxTQVhLO0FBQUEsVUFZTHNGLFVBWkssVUFZTEEsVUFaSztBQUFBLFVBYUtHLFdBYkwsVUFhTGxDLFFBYks7O0FBQUEsVUFpQkx0RCxJQWpCSyxHQXlCSHRELFFBekJHLENBaUJMc0QsSUFqQks7QUFBQSxVQWtCTHlGLE9BbEJLLEdBeUJIL0ksUUF6QkcsQ0FrQkwrSSxPQWxCSztBQUFBLFVBbUJMQyxXQW5CSyxHQXlCSGhKLFFBekJHLENBbUJMZ0osV0FuQks7QUFBQSxVQW9CQ0MsYUFwQkQsR0F5QkhqSixRQXpCRyxDQW9CTGtKLElBcEJLO0FBQUEsVUFxQkNDLGFBckJELEdBeUJIbkosUUF6QkcsQ0FxQkxvSixJQXJCSztBQUFBLFVBc0JMQyxrQkF0QkssR0F5QkhySixRQXpCRyxDQXNCTHFKLGtCQXRCSztBQUFBLFVBdUJMQyxvQkF2QkssR0F5Qkh0SixRQXpCRyxDQXVCTHNKLG9CQXZCSztBQUFBLFVBd0JGQyxJQXhCRSw0QkF5Qkh2SixRQXpCRzs7QUEyQlAsVUFBTXNJLE1BQU0sZ0JBQUVsTixHQUFGLENBQU0rQyxHQUFOLEVBQVdGLFFBQVgsQ0FBWjtBQTNCTyxVQTRCQzhGLGdCQTVCRCxHQTRCc0JWLFNBNUJ0QixDQTRCQ1UsZ0JBNUJEOztBQTZCUCxVQUFNeUYsVUFBVSxLQUFLQyxRQUFMLENBQWMvQyxLQUFkLENBQWhCOztBQUVBLGFBQ0U7QUFBQTtBQUFBLG1CQUFJLE9BQVE5QyxLQUFaLEVBQW9CLFdBQVlvQyxTQUFoQyxJQUFpRHdELE9BQWpEO0FBRUtuRyxrQkFBVUMsSUFBVixLQUFtQixnQkFBTTNJLG1CQUF6QixJQUFnRCxDQUFDb0osZ0JBQWxELEdBRUksb0VBQ09WLFNBRFA7QUFFRSxrQkFBU2lGLEdBRlg7QUFHRSxvQkFBV08sUUFIYjtBQUlFLG9CQUFXckssUUFKYjtBQUtFLG9CQUFXLENBQUNtSztBQUxkLFdBRkosR0FVSSxJQVpSO0FBZUl2SCxnQkFBUXJDLEdBQVIsQ0FBWSxVQUFDdUYsTUFBRCxFQUFTSyxLQUFULEVBQW1CO0FBQzdCLGNBQUksQ0FBQ0wsT0FBT0MsTUFBWixFQUFvQjtBQUFBLGdCQUNWL0QsU0FEVSxHQUNJOEQsTUFESixDQUNWOUQsU0FEVTs7QUFFbEIsZ0JBQU0ySCxVQUFVLGdCQUFFL00sR0FBRixDQUFNK0MsR0FBTixFQUFXcUMsU0FBWCxDQUFoQjtBQUNBLGdCQUFJb0csV0FBVyxnQkFBRTNKLFNBQUYsQ0FBWXFILE9BQU9zQyxRQUFuQixJQUErQnRDLE9BQU9zQyxRQUF0QyxHQUFpRCxJQUFoRTtBQUNBLGdCQUFJcEcsY0FBY3ZDLFFBQWQsSUFBMEIsQ0FBQzZLLFdBQS9CLEVBQTRDbEMsV0FBVyxLQUFYO0FBQzVDLGdCQUFJLGdCQUFFdkssVUFBRixDQUFhaUksT0FBT3NDLFFBQXBCLENBQUosRUFBbUM7QUFDakNBLHlCQUFXdEMsT0FBT3NDLFFBQVAsQ0FBZ0J1QixPQUFoQixFQUF5QmhLLEdBQXpCLEVBQThCMEssUUFBOUIsRUFBd0NsRSxLQUF4QyxDQUFYO0FBQ0Q7QUFDRCxnQkFBSWtFLGFBQWFJLGFBQWIsSUFBOEJ0RSxVQUFVd0UsYUFBNUMsRUFBMkQ7QUFDekQsa0JBQUlPLGdCQUFnQnBGLE9BQU91QyxhQUFQLElBQXdCLEVBQTVDO0FBQ0Esa0JBQUk4QyxrQkFBa0JyRixPQUFPd0MsZUFBN0I7QUFDQSxrQkFBSSxnQkFBRXpLLFVBQUYsQ0FBYWlJLE9BQU91QyxhQUFwQixDQUFKLEVBQXdDO0FBQ3RDNkMsZ0NBQWdCcEYsT0FBT3VDLGFBQVAsQ0FBcUJzQixPQUFyQixFQUE4QmhLLEdBQTlCLEVBQW1DMEssUUFBbkMsRUFBNkNsRSxLQUE3QyxDQUFoQjtBQUNEO0FBQ0Qsa0JBQUksZ0JBQUV0SSxVQUFGLENBQWFpSSxPQUFPd0MsZUFBcEIsQ0FBSixFQUEwQztBQUN4QzZDLGtDQUFrQnJGLE9BQU93QyxlQUFQLENBQXVCcUIsT0FBdkIsRUFBZ0NoSyxHQUFoQyxFQUFxQzBLLFFBQXJDLEVBQStDbEUsS0FBL0MsQ0FBbEI7QUFDRDtBQUNELHFCQUNFLDhCQUFDLFdBQUQ7QUFDRSxxQkFBU3dELE9BQVQsU0FBb0J4RCxLQUR0QjtBQUVFLHFCQUFNeEcsR0FGUjtBQUdFLDBCQUFXMEssUUFIYjtBQUlFLHdCQUFTdkUsTUFKWDtBQUtFLDZCQUFjSyxLQUxoQjtBQU1FLDJCQUFZZ0YsZUFOZDtBQU9FLHVCQUFRRDtBQVBWLGlCQVFPSCxJQVJQLEVBREY7QUFZRDtBQUNELG1CQUNFO0FBQ0UsbUJBQVNwQixPQUFULFNBQW9CeEQsS0FEdEI7QUFFRSxtQkFBTXhHLEdBRlI7QUFHRSx3QkFBVzBLLFFBSGI7QUFJRSwyQkFBY2xFLEtBSmhCO0FBS0Usc0JBQVNMLE1BTFg7QUFNRSx1QkFBVXlFLE9BTlo7QUFPRSx3QkFBV25DLFFBUGI7QUFRRSwyQkFBY3RELFNBQVMrRixrQkFSekI7QUFTRSw2QkFBZ0IvRixTQUFTZ0c7QUFUM0IsY0FERjtBQWFEO0FBQ0QsaUJBQU8sS0FBUDtBQUNELFNBOUNEO0FBZkosT0FERjtBQWtFRDs7OztFQWxHZSxrRDs7QUFxR2xCVixJQUFJaEcsU0FBSixHQUFnQjtBQUNkekUsT0FBSyxvQkFBVWdGLE1BQVYsQ0FBaUJMLFVBRFI7QUFFZCtGLFlBQVUsb0JBQVUxQixNQUFWLENBQWlCckUsVUFGYjtBQUdkMUIsV0FBUyxvQkFBVTJCLEtBQVYsQ0FBZ0JELFVBSFg7QUFJZGMsU0FBTyxvQkFBVVQsTUFKSDtBQUtkNkMsYUFBVyxvQkFBVW5ELE1BTFA7QUFNZDZELFNBQU8sb0JBQVV2RDtBQU5ILENBQWhCOztBQVNBeUYsSUFBSXhFLFlBQUosR0FBbUI7QUFDakJ3QyxZQUFVLElBRE87QUFFakJoRCxTQUFPLEVBRlU7QUFHakJvQyxhQUFXLElBSE07QUFJakJVLFNBQU87QUFKVSxDQUFuQjs7a0JBT2VrQyxHOzs7Ozs7Ozs7Ozs7Ozs7OztBQy9IZjs7OztBQUNBOzs7O0FBRUE7Ozs7Ozs7Ozs7K2VBSkE7OztJQU1NZ0IsSTs7O0FBQ0osZ0JBQVl0SyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsNEdBQ1hBLEtBRFc7O0FBRWpCLFVBQUt1SyxpQkFBTCxHQUF5QixNQUFLQSxpQkFBTCxDQUF1Qi9CLElBQXZCLE9BQXpCO0FBRmlCO0FBR2xCOzs7O3NDQUVpQmxNLEMsRUFBRztBQUFBLG1CQUM0RCxLQUFLMEQsS0FEakU7QUFBQSxVQUNYZ0YsTUFEVyxVQUNYQSxNQURXO0FBQUEsVUFDSHlFLE9BREcsVUFDSEEsT0FERztBQUFBLFVBQ01GLFFBRE4sVUFDTUEsUUFETjtBQUFBLFVBQ2dCaUIsV0FEaEIsVUFDZ0JBLFdBRGhCO0FBQUEsVUFDNkJyRyxXQUQ3QixVQUM2QkEsV0FEN0I7QUFBQSxVQUMwQ3NHLGFBRDFDLFVBQzBDQSxhQUQxQztBQUFBLFVBRVh2RCxNQUZXLEdBRUFsQyxNQUZBLENBRVhrQyxNQUZXOztBQUduQixVQUFJQSxNQUFKLEVBQVk7QUFDVixZQUFJL0MsV0FBSixFQUFpQjtBQUNmLGNBQU1xQyxjQUFjVSxPQUFPVCxPQUEzQjtBQUNBLGNBQUksZ0JBQUUxSixVQUFGLENBQWF5SixXQUFiLENBQUosRUFBK0JBLFlBQVlsSyxDQUFaO0FBQ2hDLFNBSEQsTUFHTyxJQUFJbU8sYUFBSixFQUFtQjtBQUN4QixjQUFNQyxnQkFBZ0J4RCxPQUFPeUQsYUFBN0I7QUFDQSxjQUFJLGdCQUFFNU4sVUFBRixDQUFhMk4sYUFBYixDQUFKLEVBQWlDQSxjQUFjcE8sQ0FBZDtBQUNsQztBQUNGO0FBQ0QsVUFBSW1OLE9BQUosRUFBYTtBQUNYQSxnQkFBUUYsUUFBUixFQUFrQmlCLFdBQWxCO0FBQ0Q7QUFDRjs7OzZCQUVRO0FBQUEsb0JBU0gsS0FBS3hLLEtBVEY7QUFBQSxVQUVMbkIsR0FGSyxXQUVMQSxHQUZLO0FBQUEsVUFHTDBLLFFBSEssV0FHTEEsUUFISztBQUFBLFVBSUx2RSxNQUpLLFdBSUxBLE1BSks7QUFBQSxVQUtMd0YsV0FMSyxXQUtMQSxXQUxLO0FBQUEsVUFNTGxELFFBTkssV0FNTEEsUUFOSztBQUFBLFVBT0xuRCxXQVBLLFdBT0xBLFdBUEs7QUFBQSxVQVFMc0csYUFSSyxXQVFMQSxhQVJLO0FBQUEsVUFXTHZKLFNBWEssR0FvQkg4RCxNQXBCRyxDQVdMOUQsU0FYSztBQUFBLFVBWUw2RixTQVpLLEdBb0JIL0IsTUFwQkcsQ0FZTCtCLFNBWks7QUFBQSxVQWFMQyxlQWJLLEdBb0JIaEMsTUFwQkcsQ0FhTGdDLGVBYks7QUFBQSxVQWNMMUMsS0FkSyxHQW9CSFUsTUFwQkcsQ0FjTFYsS0FkSztBQUFBLFVBZUx2QyxPQWZLLEdBb0JIaUQsTUFwQkcsQ0FlTGpELE9BZks7QUFBQSxVQWdCTHVFLEtBaEJLLEdBb0JIdEIsTUFwQkcsQ0FnQkxzQixLQWhCSztBQUFBLFVBaUJMWSxNQWpCSyxHQW9CSGxDLE1BcEJHLENBaUJMa0MsTUFqQks7QUFBQSxVQWtCTEMsS0FsQkssR0FvQkhuQyxNQXBCRyxDQWtCTG1DLEtBbEJLO0FBQUEsVUFtQkxDLEtBbkJLLEdBb0JIcEMsTUFwQkcsQ0FtQkxvQyxLQW5CSzs7QUFxQlAsVUFBSXdELGtCQUFKO0FBQ0EsVUFBSXhFLFlBQVksRUFBaEI7QUFDQSxVQUFJeUMsVUFBVSxnQkFBRS9NLEdBQUYsQ0FBTStDLEdBQU4sRUFBV3FDLFNBQVgsQ0FBZDs7QUFFQSxVQUFNK0UseUJBQ0QsZ0JBQUVsSixVQUFGLENBQWFxSyxLQUFiLElBQXNCQSxNQUFNeUIsT0FBTixFQUFlaEssR0FBZixFQUFvQjBLLFFBQXBCLEVBQThCaUIsV0FBOUIsQ0FBdEIsR0FBbUVwRCxLQURsRSxFQUVERixNQUZDLENBQU47O0FBS0EsVUFBTWIsY0FBYyxnQkFBRXRKLFVBQUYsQ0FBYWdGLE9BQWIsSUFDaEJBLFFBQVE4RyxPQUFSLEVBQWlCaEssR0FBakIsRUFBc0IwSyxRQUF0QixFQUFnQ2lCLFdBQWhDLENBRGdCLEdBRWhCekksT0FGSjs7QUFJQSxVQUFJdUMsS0FBSixFQUFXO0FBQ1Q4QixvQkFBWSxnQkFBRXJKLFVBQUYsQ0FBYXVILEtBQWIsSUFBc0JBLE1BQU11RSxPQUFOLEVBQWVoSyxHQUFmLEVBQW9CMEssUUFBcEIsRUFBOEJpQixXQUE5QixDQUF0QixHQUFtRWxHLEtBQS9FO0FBQ0Q7O0FBRUQsVUFBSWdDLEtBQUosRUFBVztBQUNUc0Usb0JBQVksZ0JBQUU3TixVQUFGLENBQWF1SixLQUFiLElBQXNCQSxNQUFNdUMsT0FBTixFQUFlaEssR0FBZixFQUFvQjBLLFFBQXBCLEVBQThCaUIsV0FBOUIsQ0FBdEIsR0FBbUUzQixPQUEvRTtBQUNBNUMsa0JBQVVLLEtBQVYsR0FBa0JzRSxTQUFsQjtBQUNEOztBQUVELFVBQUk3RCxTQUFKLEVBQWU7QUFDYjhCLGtCQUFVN0QsT0FBTytCLFNBQVAsQ0FBaUI4QixPQUFqQixFQUEwQmhLLEdBQTFCLEVBQStCMEssUUFBL0IsRUFBeUN2QyxlQUF6QyxDQUFWO0FBQ0Q7O0FBRUQsVUFBSUcsS0FBSixFQUFXO0FBQ1RmLGtCQUFVRyxTQUFWLEdBQ0UsZ0JBQUV4SixVQUFGLENBQWFvSyxLQUFiLElBQXNCQSxNQUFNMEIsT0FBTixFQUFlaEssR0FBZixFQUFvQjBLLFFBQXBCLEVBQThCaUIsV0FBOUIsQ0FBdEIsR0FBbUVyRCxLQURyRTtBQUVEOztBQUVELFVBQUlkLFdBQUosRUFBaUJKLFVBQVVTLFNBQVYsR0FBc0JMLFdBQXRCOztBQUVqQixVQUFJLENBQUMsZ0JBQUVoSixhQUFGLENBQWdCK0ksU0FBaEIsQ0FBTCxFQUFpQ0gsVUFBVTNCLEtBQVYsR0FBa0I4QixTQUFsQjtBQUNqQyxVQUFJakMsZUFBZW1ELFFBQW5CLEVBQTZCO0FBQzNCckIsa0JBQVVRLE9BQVYsR0FBb0IsS0FBSzhELGlCQUF6QjtBQUNELE9BRkQsTUFFTyxJQUFJRSxpQkFBaUJuRCxRQUFyQixFQUErQjtBQUNwQ3JCLGtCQUFVMEUsYUFBVixHQUEwQixLQUFLSixpQkFBL0I7QUFDRDtBQUNELGFBQ0U7QUFBQTtBQUFTdEUsaUJBQVQ7QUFBdUI0QztBQUF2QixPQURGO0FBR0Q7Ozs7OztBQUdIeUIsS0FBS2hILFNBQUwsR0FBaUI7QUFDZnpFLE9BQUssb0JBQVVnRixNQUFWLENBQWlCTCxVQURQO0FBRWYrRixZQUFVLG9CQUFVMUIsTUFBVixDQUFpQnJFLFVBRlo7QUFHZndCLFVBQVEsb0JBQVVuQixNQUFWLENBQWlCTCxVQUhWO0FBSWZnSCxlQUFhLG9CQUFVM0MsTUFBVixDQUFpQnJFO0FBSmYsQ0FBakI7O2tCQU9lOEcsSTs7Ozs7Ozs7Ozs7Ozs7O0FDbEdmOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFOQTs7Ozs7O0lBUXFCTyxhOzs7QUFXbkIsMkJBQWM7QUFBQTs7QUFBQTs7QUFFWixVQUFLQyxXQUFMLEdBQW1CLE1BQUtBLFdBQUwsQ0FBaUJ0QyxJQUFqQixPQUFuQjtBQUZZO0FBR2I7Ozs7MENBRXFCakgsUyxFQUFXO0FBQUEsVUFDdkJyQyxRQUR1QixHQUNWLEtBQUtjLEtBREssQ0FDdkJkLFFBRHVCOzs7QUFHL0IsYUFBT3FDLFVBQVVyQyxRQUFWLEtBQXVCQSxRQUE5QjtBQUNEOzs7Z0NBRVc1QyxDLEVBQUc7QUFBQSxtQkFTVCxLQUFLMEQsS0FUSTtBQUFBLFVBRUwrSyxTQUZLLFVBRVgvRyxJQUZXO0FBQUEsVUFHWGdILE1BSFcsVUFHWEEsTUFIVztBQUFBLFVBSVg5TCxRQUpXLFVBSVhBLFFBSlc7QUFBQSxVQUtYMEQsV0FMVyxVQUtYQSxXQUxXO0FBQUEsVUFNWHFJLFFBTlcsVUFNWEEsUUFOVztBQUFBLFVBT1gxQixRQVBXLFVBT1hBLFFBUFc7QUFBQSxVQVFYckYsYUFSVyxVQVFYQSxhQVJXOzs7QUFXYixVQUFJK0csUUFBSixFQUFjO0FBQ2QsVUFBSS9HLGFBQUosRUFBbUI7O0FBRW5CLFVBQU1pRSxVQUFVNEMsY0FBYyxnQkFBTTVQLGlCQUFwQixHQUNaLElBRFksR0FFWixDQUFDK0QsUUFGTDs7QUFJQTBELGtCQUFZb0ksTUFBWixFQUFvQjdDLE9BQXBCLEVBQTZCb0IsUUFBN0IsRUFBdUNqTixDQUF2QztBQUNEOzs7NkJBRVE7QUFBQSxvQkFLSCxLQUFLMEQsS0FMRjtBQUFBLFVBRUMrSyxTQUZELFdBRUwvRyxJQUZLO0FBQUEsVUFHTDlFLFFBSEssV0FHTEEsUUFISztBQUFBLFVBSUwrTCxRQUpLLFdBSUxBLFFBSks7OztBQU9QLGFBQ0U7QUFBQTtBQUFBLFVBQUksU0FBVSxLQUFLSCxXQUFuQjtBQUNFO0FBQ0UsZ0JBQU9DLFNBRFQ7QUFFRSxtQkFBVTdMLFFBRlo7QUFHRSxvQkFBVytMO0FBSGI7QUFERixPQURGO0FBU0Q7Ozs7OztBQTNEa0JKLGEsQ0FDWnZILFMsR0FBWTtBQUNqQlUsUUFBTSxvQkFBVVQsTUFBVixDQUFpQkMsVUFETjtBQUVqQndILFVBQVEsb0JBQVUvRCxHQUZEO0FBR2pCL0gsWUFBVSxvQkFBVXlFLElBSEg7QUFJakJmLGVBQWEsb0JBQVUzRSxJQUpOO0FBS2pCZ04sWUFBVSxvQkFBVXRILElBTEg7QUFNakI0RixZQUFVLG9CQUFVMUIsTUFOSDtBQU9qQjNELGlCQUFlLG9CQUFVUDtBQVBSLEM7a0JBREFrSCxhOzs7Ozs7Ozs7Ozs7Ozs7QUNSckI7Ozs7Ozs7Ozs7OztBQUVBLElBQU0zRCxTQUFTLENBQ2IsU0FEYSxFQUViLGNBRmEsRUFHYixjQUhhLENBQWY7O2tCQU1lO0FBQUE7QUFBQTs7QUFFWCwrQkFBWWxILEtBQVosRUFBbUI7QUFBQTs7QUFBQSx3SUFDWEEsS0FEVzs7QUFFakIsWUFBS2tMLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxZQUFLQyx5QkFBTCxHQUFpQyxNQUFLQSx5QkFBTCxDQUErQjNDLElBQS9CLE9BQWpDO0FBQ0EsWUFBSzRDLHVCQUFMLEdBQStCLE1BQUtBLHVCQUFMLENBQTZCNUMsSUFBN0IsT0FBL0I7QUFKaUI7QUFLbEI7O0FBUFU7QUFBQTtBQUFBLGdEQVNlNkMsRUFUZixFQVNtQjtBQUFBOztBQUM1QixlQUFPLFVBQUMvTyxDQUFELEVBQU87QUFBQSx1QkFDYyxPQUFLMEQsS0FEbkI7QUFBQSxjQUNKbkIsR0FESSxVQUNKQSxHQURJO0FBQUEsY0FDQzBLLFFBREQsVUFDQ0EsUUFERDs7QUFFWjhCLGFBQUcvTyxDQUFILEVBQU11QyxHQUFOLEVBQVcwSyxRQUFYO0FBQ0QsU0FIRDtBQUlEO0FBZFU7QUFBQTtBQUFBLDhDQWdCYThCLEVBaEJiLEVBZ0JpQjtBQUFBOztBQUMxQixlQUFPLFVBQUMvTyxDQUFELEVBQU87QUFBQSx3QkFnQlIsT0FBSzBELEtBaEJHO0FBQUEsY0FFVm5CLEdBRlUsV0FFVkEsR0FGVTtBQUFBLGNBR1ZLLFFBSFUsV0FHVkEsUUFIVTtBQUFBLGNBSVZQLFFBSlUsV0FJVkEsUUFKVTtBQUFBLGNBS1YwSyxVQUxVLFdBS1ZBLFVBTFU7QUFBQSxjQU1WRSxRQU5VLFdBTVZBLFFBTlU7QUFBQSwwQ0FPVnhGLFNBUFU7QUFBQSxjQVFSbkIsV0FSUSxxQkFRUkEsV0FSUTtBQUFBLGNBU1J1QixXQVRRLHFCQVNSQSxXQVRRO0FBQUEseUNBV1Z6RCxRQVhVO0FBQUEsY0FZUnNELElBWlEsb0JBWVJBLElBWlE7QUFBQSxjQWFSZ0csb0JBYlEsb0JBYVJBLG9CQWJRO0FBQUEsY0FjUnNCLGlCQWRRLG9CQWNSQSxpQkFkUTs7O0FBa0JaLGNBQU1DLFVBQVUsU0FBVkEsT0FBVSxHQUFNO0FBQ3BCLGdCQUFJRixFQUFKLEVBQVE7QUFDTkEsaUJBQUcvTyxDQUFILEVBQU11QyxHQUFOLEVBQVcwSyxRQUFYO0FBQ0Q7QUFDRCxnQkFBSUYsVUFBSixFQUFnQjtBQUNkLGtCQUFNTCxNQUFNLGdCQUFFbE4sR0FBRixDQUFNK0MsR0FBTixFQUFXRixRQUFYLENBQVo7QUFDQWlFLDBCQUFZb0csR0FBWixFQUFpQixDQUFDOUosUUFBbEIsRUFBNEJxSyxRQUE1QixFQUFzQ2pOLENBQXRDO0FBQ0Q7QUFDRixXQVJEOztBQVVBLGNBQUkwSCxTQUFTZ0csb0JBQVQsSUFBaUM3RixXQUFyQyxFQUFrRDtBQUNoRCxtQkFBSytHLFFBQUwsSUFBaUIsQ0FBakI7QUFDQSw0QkFBRWxOLFFBQUYsQ0FBVyxZQUFNO0FBQ2Ysa0JBQUksT0FBS2tOLFFBQUwsS0FBa0IsQ0FBdEIsRUFBeUI7QUFDdkJLO0FBQ0Q7QUFDRCxxQkFBS0wsUUFBTCxHQUFnQixDQUFoQjtBQUNELGFBTEQsRUFLR0ksaUJBTEg7QUFNRCxXQVJELE1BUU87QUFDTEM7QUFDRDtBQUNGLFNBdkNEO0FBd0NEO0FBekRVO0FBQUE7QUFBQSxpQ0EyRFU7QUFBQTs7QUFBQSxZQUFabkUsS0FBWSx1RUFBSixFQUFJOztBQUNuQixZQUFNb0UsV0FBVyxFQUFqQjtBQUNBLFlBQUksS0FBS3hMLEtBQUwsQ0FBVytELFNBQVgsSUFBd0IsS0FBSy9ELEtBQUwsQ0FBVytELFNBQVgsQ0FBcUJHLGFBQWpELEVBQWdFO0FBQzlEc0gsbUJBQVMvRSxPQUFULEdBQW1CLEtBQUsyRSx1QkFBTCxDQUE2QmhFLE1BQU1YLE9BQW5DLENBQW5CO0FBQ0Q7QUFDRHJKLGVBQU9JLElBQVAsQ0FBWTRKLEtBQVosRUFBbUJxRSxPQUFuQixDQUEyQixVQUFDQyxJQUFELEVBQVU7QUFDbkMsY0FBSSxDQUFDRixTQUFTRSxJQUFULENBQUwsRUFBcUI7QUFDbkIsZ0JBQUl4RSxPQUFPNUgsUUFBUCxDQUFnQm9NLElBQWhCLENBQUosRUFBMkI7QUFDekJGLHVCQUFTRSxJQUFULElBQWlCLE9BQUtQLHlCQUFMLENBQStCL0QsTUFBTXNFLElBQU4sQ0FBL0IsQ0FBakI7QUFDRCxhQUZELE1BRU87QUFDTEYsdUJBQVNFLElBQVQsSUFBaUJ0RSxNQUFNc0UsSUFBTixDQUFqQjtBQUNEO0FBQ0Y7QUFDRixTQVJEO0FBU0EsZUFBT0YsUUFBUDtBQUNEO0FBMUVVOztBQUFBO0FBQUEsSUFDbUJwSyxVQURuQjtBQUFBLEM7Ozs7Ozs7Ozs7Ozs7QUNSZjs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNdUssYUFBYSxTQUFiQSxVQUFhO0FBQUEsTUFBRzlDLE9BQUgsUUFBR0EsT0FBSDtBQUFBLE1BQVkrQyxPQUFaLFFBQVlBLE9BQVo7QUFBQSxTQUNqQjtBQUFBO0FBQUE7QUFDRTtBQUFBO0FBQUE7QUFDRSx1QkFBWSxVQURkO0FBRUUsaUJBQVVBLE9BRlo7QUFHRSxtQkFBVTtBQUhaO0FBS0kvQztBQUxKO0FBREYsR0FEaUI7QUFBQSxDQUFuQjs7QUFZQThDLFdBQVdySSxTQUFYLEdBQXVCO0FBQ3JCdUYsV0FBUyxvQkFBVTVCLEdBREU7QUFFckIyRSxXQUFTLG9CQUFVL0Q7QUFGRSxDQUF2Qjs7QUFLQThELFdBQVc3RyxZQUFYLEdBQTBCO0FBQ3hCK0QsV0FBUyxJQURlO0FBRXhCK0MsV0FBUztBQUZlLENBQTFCOztrQkFLZUQsVTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QmY7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztrQkFFZTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSxzQ0FFSztBQUFBLFlBQ05oTixRQURNLEdBQ08sS0FBS3FCLEtBRFosQ0FDTnJCLFFBRE07O0FBRWQsWUFBSSxDQUFDQSxRQUFMLEVBQWU7QUFDYixnQkFBTSxJQUFJOUIsS0FBSixDQUFVLDRDQUFWLENBQU47QUFDRDtBQUNELFlBQUksS0FBS3dHLGlCQUFMLENBQXVCLEtBQXZCLEtBQWlDLENBQXJDLEVBQXdDO0FBQ3RDLGdCQUFNLElBQUl4RyxLQUFKLENBQVUsNkJBQVYsQ0FBTjtBQUNEO0FBQ0Y7QUFWVTtBQUFBO0FBQUEsZ0NBWUQ7QUFDUixlQUFPLEtBQUttRCxLQUFMLENBQVdqQixJQUFYLENBQWdCakMsTUFBaEIsS0FBMkIsQ0FBbEM7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFoQlc7QUFBQTtBQUFBLDRDQXVCV2lFLE9BdkJYLEVBdUJvQjtBQUFBLFlBQ3JCZ0QsU0FEcUIsR0FDUCxLQUFLL0QsS0FERSxDQUNyQitELFNBRHFCO0FBQUEsWUFFckIxSSxtQkFGcUIsbUJBRXJCQSxtQkFGcUI7OztBQUk3QixZQUFJLGdCQUFFc0MsU0FBRixDQUFZb0csU0FBWixDQUFKLEVBQTRCO0FBQzFCLDhCQUNLQSxTQURMLEVBRUtoRCxPQUZMO0FBSUQ7O0FBRUQsZUFBTztBQUNMaUQsZ0JBQU0zSTtBQURELFNBQVA7QUFHRDs7QUFFRDs7Ozs7Ozs7O0FBdkNXO0FBQUE7QUFBQSx1REErQ2tDO0FBQUEsWUFBZDBGLE9BQWMsdUVBQUosRUFBSTtBQUFBLFlBQ25DZ0QsU0FEbUMsR0FDckIsS0FBSy9ELEtBRGdCLENBQ25DK0QsU0FEbUM7O0FBQUEsWUFFbkNmLGVBRm1DLEdBRVNqQyxPQUZULENBRW5DaUMsZUFGbUM7QUFBQSxnQ0FFU2pDLE9BRlQsQ0FFbEI3QixRQUZrQjtBQUFBLFlBRWxCQSxRQUZrQixxQ0FFUCxFQUZPO0FBQUEsWUFFQStLLElBRkEsNEJBRVNsSixPQUZUOztBQUFBLFlBSXpDMUYsbUJBSnlDLG1CQUl6Q0EsbUJBSnlDO0FBQUEsWUFJcEJDLHVCQUpvQixtQkFJcEJBLHVCQUpvQjtBQUFBLFlBS3pDQyw2QkFMeUMsbUJBS3pDQSw2QkFMeUM7QUFBQSxZQUtWQyx5QkFMVSxtQkFLVkEseUJBTFU7OztBQVEzQyxZQUFJLGdCQUFFbUMsU0FBRixDQUFZb0csU0FBWixDQUFKLEVBQTRCO0FBQzFCLGNBQUkwRSxzQkFBSjs7QUFFQTtBQUNBLGNBQUl6RixlQUFKLEVBQXFCeUYsZ0JBQWdCbk4sdUJBQWhCLENBQXJCLEtBQ0ssSUFBSTRELFNBQVNwQyxNQUFULEtBQW9CLENBQXhCLEVBQTJCMkwsZ0JBQWdCak4seUJBQWhCLENBQTNCLEtBQ0FpTixnQkFBZ0JsTiw2QkFBaEI7O0FBRUwsOEJBQ0t3SSxTQURMLEVBRUtrRyxJQUZMO0FBR0V4QjtBQUhGO0FBS0Q7O0FBRUQsZUFBTztBQUNMekUsZ0JBQU0zSTtBQURELFNBQVA7QUFHRDtBQXpFVTs7QUFBQTtBQUFBLElBQ2UsOEJBQWUrRixVQUFmLENBRGY7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JDSkE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsMENBRW1DO0FBQUEsWUFBNUJ5SyxtQkFBNEIsdUVBQU4sSUFBTTs7QUFDNUMsWUFBTUMsWUFBWSxLQUFLOUwsS0FBTCxDQUFXOEIsT0FBWCxDQUFtQnpDLE1BQW5CLENBQTBCO0FBQUEsaUJBQUssQ0FBQzBNLEVBQUU5RyxNQUFSO0FBQUEsU0FBMUIsRUFBMENuSSxNQUE1RDtBQUNBLFlBQUksQ0FBQytPLG1CQUFMLEVBQTBCLE9BQU9DLFNBQVA7QUFDMUIsWUFBSSxLQUFLOUwsS0FBTCxDQUFXK0QsU0FBWCxJQUF3QixDQUFDLEtBQUsvRCxLQUFMLENBQVcrRCxTQUFYLENBQXFCVSxnQkFBbEQsRUFBb0U7QUFDbEUsaUJBQU9xSCxZQUFZLENBQW5CO0FBQ0Q7QUFDRCxlQUFPQSxTQUFQO0FBQ0Q7QUFUVTs7QUFBQTtBQUFBLElBQ2dCMUssVUFEaEI7QUFBQSxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0VmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFSQTtBQUNBOzs7QUFTQSxJQUFNNEssZ0JBQWdCLFNBQWhCQSxhQUFnQjtBQUFBO0FBQUE7O0FBRWxCLHFDQUFZaE0sS0FBWixFQUFtQjtBQUFBOztBQUFBLG9KQUNYQSxLQURXOztBQUVqQixZQUFLSixLQUFMLEdBQWEsb0JBQVVJLE1BQU1yQixRQUFoQixDQUFiO0FBQ0EsWUFBS2lCLEtBQUwsQ0FBV2IsSUFBWCxHQUFrQmlCLE1BQU1qQixJQUF4QjtBQUNBLFlBQUtrTixjQUFMO0FBSmlCO0FBS2xCOztBQVBpQjtBQUFBO0FBQUEsZ0RBU1ExSyxTQVRSLEVBU21CO0FBQ25DLGFBQUszQixLQUFMLENBQVdzTSxVQUFYLENBQXNCM0ssVUFBVXhDLElBQWhDO0FBQ0Q7QUFYaUI7QUFBQTtBQUFBLHVDQWFEO0FBQ2YsYUFBS29OLGFBQUwsR0FBcUJDLElBQXJCO0FBRGUscUJBRThDLEtBQUtwTSxLQUZuRDtBQUFBLFlBRVBRLFVBRk8sVUFFUEEsVUFGTztBQUFBLFlBRUtzQixPQUZMLFVBRUtBLE9BRkw7QUFBQSxZQUVjekMsTUFGZCxVQUVjQSxNQUZkO0FBQUEsWUFFc0IwRSxTQUZ0QixVQUVzQkEsU0FGdEI7QUFBQSxZQUVpQ3JELFFBRmpDLFVBRWlDQSxRQUZqQzs7QUFHZixZQUFJRixVQUFKLEVBQWdCO0FBQUEsY0FDTjZMLGNBRE0sR0FDYTdMLFVBRGIsQ0FDTjZMLGNBRE07O0FBRWQsZUFBS0YsYUFBTCxHQUFxQkUsZUFBZSxLQUFLRixhQUFwQixFQUFtQztBQUN0REc7QUFEc0QsV0FBbkMsQ0FBckI7QUFHRDs7QUFFRCxZQUFJeEssUUFBUXpDLE1BQVIsQ0FBZTtBQUFBLGlCQUFPa04sSUFBSTlMLElBQVg7QUFBQSxTQUFmLEVBQWdDM0QsTUFBaEMsR0FBeUMsQ0FBN0MsRUFBZ0Q7QUFDOUMsZUFBS3FQLGFBQUwsR0FBcUIsdUJBQVMsS0FBS0EsYUFBZCxDQUFyQjtBQUNEOztBQUVELFlBQUk5TSxNQUFKLEVBQVk7QUFBQSxjQUNGZ04sZUFERSxHQUNpQmhOLE1BRGpCLENBQ0ZnTixjQURFOztBQUVWLGVBQUtGLGFBQUwsR0FBcUJFLGdCQUFlLEtBQUtGLGFBQXBCLEVBQW1DO0FBQ3RESyw4QkFEc0Q7QUFFdERGO0FBRnNELFdBQW5DLENBQXJCO0FBSUQ7O0FBRUQsWUFBSTVMLFFBQUosRUFBYztBQUFBLGNBQ0oyTCxnQkFESSxHQUNlM0wsUUFEZixDQUNKMkwsY0FESTs7QUFFWixlQUFLRixhQUFMLEdBQXFCRSxpQkFBZSxLQUFLRixhQUFwQixFQUFtQztBQUN0REssOEJBRHNEO0FBRXRERjtBQUZzRCxXQUFuQyxDQUFyQjtBQUlEOztBQUVELFlBQUl2SSxTQUFKLEVBQWU7QUFDYixlQUFLb0ksYUFBTCxHQUFxQix1QkFBYyxLQUFLQSxhQUFuQixDQUFyQjtBQUNEO0FBQ0Y7QUE5Q2lCO0FBQUE7QUFBQSwrQkFnRFQ7QUFDUCxZQUFNTSx5QkFDRCxLQUFLek0sS0FESjtBQUVKSixpQkFBTyxLQUFLQTtBQUZSLFVBQU47O0FBS0EsZUFDRSxtQ0FBTSxhQUFOLEVBQXlCNk0sU0FBekIsQ0FERjtBQUdEO0FBekRpQjs7QUFBQTtBQUFBLElBQ2tCLCtDQURsQjtBQUFBLENBQXRCOztrQkE0RGVULGE7Ozs7Ozs7Ozs7Ozs7cWpCQ3RFZjs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7O0lBRXFCVSxLO0FBQ25CLGlCQUFZL04sUUFBWixFQUFzQjtBQUFBOztBQUNwQixTQUFLZ08sS0FBTCxHQUFhLEVBQWI7QUFDQSxTQUFLQyxhQUFMLEdBQXFCLEVBQXJCO0FBQ0EsU0FBS0MsU0FBTCxHQUFpQmxPLFFBQWpCO0FBQ0EsU0FBS21PLFVBQUwsR0FBa0JDLFNBQWxCO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQkQsU0FBbEI7QUFDQSxTQUFLRSxTQUFMLEdBQWlCLEVBQWpCO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUNBLFNBQUtDLEtBQUwsR0FBYUosU0FBYjtBQUNBLFNBQUtLLFlBQUwsR0FBb0JMLFNBQXBCO0FBQ0Q7Ozs7eUJBRUk5TCxLLEVBQU9DLFMsRUFBV0MsUSxFQUFVO0FBQy9CLFVBQU10QyxNQUFNLHlCQUFjLElBQWQsRUFBb0JvQyxLQUFwQixDQUFaO0FBQ0EsVUFBSXBDLEdBQUosRUFBUyxnQkFBRXRDLEdBQUYsQ0FBTXNDLEdBQU4sRUFBV3FDLFNBQVgsRUFBc0JDLFFBQXRCO0FBQ1Y7OztrQ0FFc0J5RCxLLEVBQU95SSxZLEVBQWM7QUFBQSxVQUFsQ25NLFNBQWtDLFFBQWxDQSxTQUFrQzs7QUFDMUMsV0FBS2IsU0FBTCxHQUFpQixxQkFBVSxJQUFWLEVBQWdCYSxTQUFoQixFQUEyQjBELEtBQTNCLEVBQWtDeUksWUFBbEMsQ0FBakI7QUFDQSxXQUFLak4sU0FBTCxHQUFpQmMsU0FBakI7QUFDRDs7O2tDQUVvQjtBQUFBLFVBQVptRyxRQUFZLFNBQVpBLFFBQVk7O0FBQ25CLFdBQUt0SSxJQUFMLEdBQVksZ0JBQUssSUFBTCxFQUFXc0ksUUFBWCxDQUFaO0FBQ0Q7OztpQ0FFWTtBQUNYLGFBQU8sS0FBS3NGLEtBQVo7QUFDRDs7OytCQUVVNU4sSSxFQUFNO0FBQ2YsV0FBSzROLEtBQUwsR0FBYTVOLElBQWI7QUFDRDs7O3dCQUVVO0FBQ1QsVUFBSTNCLE9BQU9JLElBQVAsQ0FBWSxLQUFLMFAsUUFBakIsRUFBMkJwUSxNQUEzQixHQUFvQyxDQUF4QyxFQUEyQztBQUN6QyxlQUFPLEtBQUs4UCxhQUFaO0FBQ0Q7QUFDRCxhQUFPLEtBQUtELEtBQVo7QUFDRCxLO3NCQUNRNU4sSSxFQUFNO0FBQ2IsVUFBSTNCLE9BQU9JLElBQVAsQ0FBWSxLQUFLMFAsUUFBakIsRUFBMkJwUSxNQUEzQixHQUFvQyxDQUF4QyxFQUEyQztBQUN6QyxhQUFLOFAsYUFBTCxHQUFxQjdOLElBQXJCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBSzROLEtBQUwsR0FBYzVOLE9BQU91TyxLQUFLQyxLQUFMLENBQVdELEtBQUtFLFNBQUwsQ0FBZXpPLElBQWYsQ0FBWCxDQUFQLEdBQTBDLEVBQXhEO0FBQ0Q7QUFDRjs7O3dCQUVrQjtBQUFFLGFBQU8sS0FBSzZOLGFBQVo7QUFBNEIsSztzQkFDaENhLFksRUFBYztBQUFFLFdBQUtiLGFBQUwsR0FBcUJhLFlBQXJCO0FBQW9DOzs7d0JBRXREO0FBQUUsYUFBTyxLQUFLWixTQUFaO0FBQXdCLEs7c0JBQzVCbE8sUSxFQUFVO0FBQUUsV0FBS2tPLFNBQUwsR0FBaUJsTyxRQUFqQjtBQUE0Qjs7O3dCQUVyQztBQUFFLGFBQU8sS0FBS21PLFVBQVo7QUFBeUIsSztzQkFDN0J6TSxTLEVBQVc7QUFBRSxXQUFLeU0sVUFBTCxHQUFrQnpNLFNBQWxCO0FBQThCOzs7d0JBRTlDO0FBQUUsYUFBTyxLQUFLOE0sS0FBWjtBQUFvQixLO3NCQUN4QmxOLEksRUFBTTtBQUFFLFdBQUtrTixLQUFMLEdBQWFsTixJQUFiO0FBQW9COzs7d0JBRW5CO0FBQUUsYUFBTyxLQUFLbU4sWUFBWjtBQUEyQixLO3NCQUMvQmxOLFcsRUFBYTtBQUFFLFdBQUtrTixZQUFMLEdBQW9CbE4sV0FBcEI7QUFBa0M7Ozt3QkFFakQ7QUFBRSxhQUFPLEtBQUs4TSxVQUFaO0FBQXlCLEs7c0JBQzdCNU0sUyxFQUFXO0FBQUUsV0FBSzRNLFVBQUwsR0FBa0I1TSxTQUFsQjtBQUE4Qjs7O3dCQUUxQztBQUFFLGFBQU8sS0FBSzZNLFNBQVo7QUFBd0IsSztzQkFDNUIvTixRLEVBQVU7QUFBRSxXQUFLK04sU0FBTCxHQUFpQi9OLFFBQWpCO0FBQTRCOzs7d0JBRXZDO0FBQUUsYUFBTyxLQUFLZ08sUUFBWjtBQUF1QixLO3NCQUMzQi9NLE8sRUFBUztBQUFFLFdBQUsrTSxRQUFMLEdBQWdCL00sT0FBaEI7QUFBMEI7Ozs7OztrQkF2RTlCdU0sSzs7Ozs7Ozs7Ozs7Ozs7QUNGckI7Ozs7QUFDQTs7Ozs7O29NQUpBO0FBQ0E7QUFDQTs7O0FBSUEsU0FBU2dCLFVBQVQsQ0FBb0IvUSxDQUFwQixFQUF1QkMsQ0FBdkIsRUFBMEI7QUFDeEIsTUFBSVYsZUFBSjtBQUNBLE1BQUksT0FBT1UsQ0FBUCxLQUFhLFFBQWpCLEVBQTJCO0FBQ3pCVixhQUFTVSxFQUFFK1EsYUFBRixDQUFnQmhSLENBQWhCLENBQVQ7QUFDRCxHQUZELE1BRU87QUFDTFQsYUFBU1MsSUFBSUMsQ0FBSixHQUFRLENBQUMsQ0FBVCxHQUFlRCxJQUFJQyxDQUFMLEdBQVUsQ0FBVixHQUFjLENBQXJDO0FBQ0Q7QUFDRCxTQUFPVixNQUFQO0FBQ0Q7O0FBRU0sSUFBTXVFLHNCQUFPLFNBQVBBLElBQU87QUFBQSxNQUFHMUIsSUFBSCxRQUFHQSxJQUFIO0FBQUEsTUFBU3NCLFNBQVQsUUFBU0EsU0FBVDtBQUFBLE1BQW9CRCxTQUFwQixRQUFvQkEsU0FBcEI7QUFBQSxTQUFvQyxVQUFDaUgsUUFBRCxFQUFjO0FBQ3BFLFFBQU1zRixxQ0FBWTVOLElBQVosRUFBTjtBQUNBNE4sVUFBTWxNLElBQU4sQ0FBVyxVQUFDOUQsQ0FBRCxFQUFJQyxDQUFKLEVBQVU7QUFDbkIsVUFBSVYsZUFBSjtBQUNBLFVBQUkwUixTQUFTLGdCQUFFOVIsR0FBRixDQUFNYSxDQUFOLEVBQVN5RCxTQUFULENBQWI7QUFDQSxVQUFJeU4sU0FBUyxnQkFBRS9SLEdBQUYsQ0FBTWMsQ0FBTixFQUFTd0QsU0FBVCxDQUFiO0FBQ0F3TixlQUFTLGdCQUFFalEsU0FBRixDQUFZaVEsTUFBWixJQUFzQkEsTUFBdEIsR0FBK0IsRUFBeEM7QUFDQUMsZUFBUyxnQkFBRWxRLFNBQUYsQ0FBWWtRLE1BQVosSUFBc0JBLE1BQXRCLEdBQStCLEVBQXhDOztBQUVBLFVBQUl4RyxRQUFKLEVBQWM7QUFDWm5MLGlCQUFTbUwsU0FBU3VHLE1BQVQsRUFBaUJDLE1BQWpCLEVBQXlCeE4sU0FBekIsRUFBb0NELFNBQXBDLENBQVQ7QUFDRCxPQUZELE1BRU87QUFDTCxZQUFJQyxjQUFjLGdCQUFNbkYsU0FBeEIsRUFBbUM7QUFDakNnQixtQkFBU3dSLFdBQVdFLE1BQVgsRUFBbUJDLE1BQW5CLENBQVQ7QUFDRCxTQUZELE1BRU87QUFDTDNSLG1CQUFTd1IsV0FBV0csTUFBWCxFQUFtQkQsTUFBbkIsQ0FBVDtBQUNEO0FBQ0Y7QUFDRCxhQUFPMVIsTUFBUDtBQUNELEtBakJEO0FBa0JBLFdBQU95USxLQUFQO0FBQ0QsR0FyQm1CO0FBQUEsQ0FBYjs7QUF1QkEsSUFBTW1CLGdDQUFZLFNBQVpBLFNBQVk7QUFBQSxTQUFTLFVBQUM5UixLQUFELEVBQVE0SSxLQUFSLEVBQWtEO0FBQUEsUUFBbkN5SSxZQUFtQyx1RUFBcEIsZ0JBQU1uUyxTQUFjOztBQUNsRixRQUFJMEosS0FBSixFQUFXLE9BQU9BLEtBQVA7O0FBRVgsUUFBSTVJLFVBQVU0RCxNQUFNUSxTQUFwQixFQUErQjtBQUM3QixhQUFPaU4sWUFBUDtBQUNEO0FBQ0QsV0FBT3pOLE1BQU1TLFNBQU4sS0FBb0IsZ0JBQU1uRixTQUExQixHQUFzQyxnQkFBTUQsUUFBNUMsR0FBdUQsZ0JBQU1DLFNBQXBFO0FBQ0QsR0FQd0I7QUFBQSxDQUFsQixDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDUDs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBSEE7OztrQkFLZTtBQUFBOztBQUFBO0FBQUE7O0FBTVgseUJBQVk4RSxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsNEhBQ1hBLEtBRFc7O0FBRWpCLFlBQUsrTixVQUFMLEdBQWtCLE1BQUtBLFVBQUwsQ0FBZ0J2RixJQUFoQixPQUFsQjtBQUZpQjtBQUdsQjs7QUFUVTtBQUFBO0FBQUEsMkNBV1U7QUFBQSxxQkFDNkMsS0FBS3hJLEtBRGxEO0FBQUEsWUFDWDhCLE9BRFcsVUFDWEEsT0FEVztBQUFBLFlBQ0Y0QyxhQURFLFVBQ0ZBLGFBREU7QUFBQSxZQUNhRyxvQkFEYixVQUNhQSxvQkFEYjtBQUFBLFlBQ21DakYsS0FEbkMsVUFDbUNBLEtBRG5DO0FBRW5CO0FBQ0E7O0FBQ0EsWUFBSThFLGlCQUFpQkEsY0FBYzVILE1BQWQsR0FBdUIsQ0FBNUMsRUFBK0M7QUFDN0MsY0FBTW9FLFlBQVl3RCxjQUFjLENBQWQsRUFBaUJ4RCxTQUFuQztBQUNBLGNBQU0wRCxRQUFRRixjQUFjLENBQWQsRUFBaUJFLEtBQS9CO0FBQ0EsY0FBTUksU0FBU2xELFFBQVF6QyxNQUFSLENBQWU7QUFBQSxtQkFBT2tOLElBQUlyTCxTQUFKLEtBQWtCQSxTQUF6QjtBQUFBLFdBQWYsQ0FBZjtBQUNBLGNBQUk4RCxPQUFPbEksTUFBUCxHQUFnQixDQUFwQixFQUF1QjtBQUNyQjhDLGtCQUFNb08sT0FBTixDQUFjaEosT0FBTyxDQUFQLENBQWQsRUFBeUJKLEtBQXpCLEVBQWdDQyxvQkFBaEM7O0FBRUEsZ0JBQUlHLE9BQU8sQ0FBUCxFQUFVOUIsTUFBZCxFQUFzQjtBQUNwQjhCLHFCQUFPLENBQVAsRUFBVTlCLE1BQVYsQ0FBaUJ0RCxNQUFNUSxTQUF2QixFQUFrQ1IsTUFBTVMsU0FBeEM7QUFDRDs7QUFFRCxnQkFBSSxLQUFLNE4sWUFBTCxNQUF1QixLQUFLbk4sa0JBQUwsRUFBM0IsRUFBc0Q7QUFDcEQsbUJBQUtvTixnQkFBTDtBQUNELGFBRkQsTUFFTztBQUNMdE8sb0JBQU11TyxNQUFOLENBQWFuSixPQUFPLENBQVAsQ0FBYjtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBakNVO0FBQUE7QUFBQSxnREFtQ2V6RCxTQW5DZixFQW1DMEI7QUFDbkMsWUFBSTZNLHFCQUFKO0FBQ0EsYUFBSyxJQUFJM1EsSUFBSSxDQUFiLEVBQWdCQSxJQUFJOEQsVUFBVU8sT0FBVixDQUFrQmhGLE1BQXRDLEVBQThDVyxLQUFLLENBQW5ELEVBQXNEO0FBQ3BELGNBQUk4RCxVQUFVTyxPQUFWLENBQWtCckUsQ0FBbEIsRUFBcUJ5RCxTQUFyQixLQUFtQ0ssVUFBVTNCLEtBQVYsQ0FBZ0JRLFNBQXZELEVBQWtFO0FBQ2hFZ08sMkJBQWU3TSxVQUFVTyxPQUFWLENBQWtCckUsQ0FBbEIsQ0FBZjtBQUNBO0FBQ0Q7QUFDRjtBQUNELFlBQUkyUSxnQkFBZ0JBLGFBQWEzTixJQUFqQyxFQUF1QztBQUNyQ2Msb0JBQVUzQixLQUFWLENBQWdCdU8sTUFBaEIsQ0FBdUJDLFlBQXZCO0FBQ0Q7QUFDRjtBQTlDVTtBQUFBO0FBQUEsaUNBZ0RBcEosTUFoREEsRUFnRFE7QUFBQSxZQUNUcEYsS0FEUyxHQUNDLEtBQUtJLEtBRE4sQ0FDVEosS0FEUzs7QUFFakJBLGNBQU1vTyxPQUFOLENBQWNoSixNQUFkLEVBQXNCK0gsU0FBdEIsRUFBaUMsS0FBSy9NLEtBQUwsQ0FBVzZFLG9CQUE1Qzs7QUFFQSxZQUFJRyxPQUFPOUIsTUFBWCxFQUFtQjtBQUNqQjhCLGlCQUFPOUIsTUFBUCxDQUFjdEQsTUFBTVEsU0FBcEIsRUFBK0JSLE1BQU1TLFNBQXJDO0FBQ0Q7O0FBRUQsWUFBSSxLQUFLNE4sWUFBTCxNQUF1QixLQUFLbk4sa0JBQUwsRUFBM0IsRUFBc0Q7QUFDcEQsZUFBS29OLGdCQUFMO0FBQ0QsU0FGRCxNQUVPO0FBQ0x0TyxnQkFBTXVPLE1BQU4sQ0FBYW5KLE1BQWI7QUFDQSxlQUFLcUosV0FBTDtBQUNEO0FBQ0Y7QUE5RFU7QUFBQTtBQUFBLCtCQWdFRjtBQUNQLGVBQ0UsOEJBQUMsSUFBRCxlQUNPLEtBQUtyTyxLQURaO0FBRUUsa0JBQVMsS0FBSytOLFVBRmhCO0FBR0UsZ0JBQU8sS0FBSy9OLEtBQUwsQ0FBV0osS0FBWCxDQUFpQmI7QUFIMUIsV0FERjtBQU9EO0FBeEVVOztBQUFBO0FBQUEsSUFDYSwrQ0FEYixVQUVKdUUsU0FGSSxHQUVRO0FBQ2pCMUQsV0FBTyxvQkFBVWlFLE1BQVYsQ0FBaUJMO0FBRFAsR0FGUjtBQUFBLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSmY7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7O0FBTUE7Ozs7Ozs7Ozs7K2VBWEE7OztrQkFhZTtBQUFBOztBQUFBO0FBQUE7O0FBT1gsaUNBQVl4RCxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsNElBQ1hBLEtBRFc7O0FBRWpCLFlBQUtzTyxlQUFMLEdBQXVCLE1BQUtBLGVBQUwsQ0FBcUI5RixJQUFyQixPQUF2QjtBQUNBLFlBQUsrRixtQkFBTCxHQUEyQixNQUFLQSxtQkFBTCxDQUF5Qi9GLElBQXpCLE9BQTNCOztBQUVBeEksWUFBTUosS0FBTixDQUFZVixRQUFaLEdBQXVCYyxNQUFNK0QsU0FBTixDQUFnQjdFLFFBQWhCLElBQTRCLEVBQW5EO0FBQ0EsWUFBS2EsS0FBTCxHQUFhO0FBQ1g2SSx5QkFBaUI1SSxNQUFNSixLQUFOLENBQVlWO0FBRGxCLE9BQWI7QUFOaUI7QUFTbEI7O0FBaEJVO0FBQUE7QUFBQSxnREFrQmVxQyxTQWxCZixFQWtCMEI7QUFDbkNBLGtCQUFVM0IsS0FBVixDQUFnQlYsUUFBaEIsR0FBMkJxQyxVQUFVd0MsU0FBVixDQUFvQjdFLFFBQXBCLElBQWdDLEVBQTNEO0FBQ0EsYUFBS3NDLFFBQUwsQ0FBYztBQUFBLGlCQUFPO0FBQ25Cb0gsNkJBQWlCckgsVUFBVTNCLEtBQVYsQ0FBZ0JWO0FBRGQsV0FBUDtBQUFBLFNBQWQ7QUFHRDs7QUFFRDs7Ozs7O0FBekJXO0FBQUE7QUFBQSxzQ0E4Qks4TCxNQTlCTCxFQThCYTdDLE9BOUJiLEVBOEJzQm9CLFFBOUJ0QixFQThCZ0NqTixDQTlCaEMsRUE4Qm1DO0FBQUEscUJBQ0ssS0FBSzBELEtBRFY7QUFBQSxzQ0FDcEMrRCxTQURvQztBQUFBLFlBQ3ZCQyxJQUR1QixvQkFDdkJBLElBRHVCO0FBQUEsWUFDakJJLFFBRGlCLG9CQUNqQkEsUUFEaUI7QUFBQSxZQUNMeEUsS0FESyxVQUNMQSxLQURLO0FBQUEsWUFFcEN6RSxpQkFGb0MsbUJBRXBDQSxpQkFGb0M7OztBQUk1QyxZQUFJcVQsNENBQW1CNU8sTUFBTVYsUUFBekIsRUFBSjs7QUFFQSxZQUFJOEUsU0FBUzdJLGlCQUFiLEVBQWdDO0FBQUU7QUFDaENxVCx5QkFBZSxDQUFDeEQsTUFBRCxDQUFmO0FBQ0QsU0FGRCxNQUVPLElBQUk3QyxPQUFKLEVBQWE7QUFBRTtBQUNwQnFHLHVCQUFhQyxJQUFiLENBQWtCekQsTUFBbEI7QUFDRCxTQUZNLE1BRUE7QUFDTHdELHlCQUFlQSxhQUFhblAsTUFBYixDQUFvQjtBQUFBLG1CQUFTN0MsVUFBVXdPLE1BQW5CO0FBQUEsV0FBcEIsQ0FBZjtBQUNEOztBQUVEcEwsY0FBTVYsUUFBTixHQUFpQnNQLFlBQWpCOztBQUVBLFlBQUlwSyxRQUFKLEVBQWM7QUFDWixjQUFNdkYsTUFBTSx5QkFBY2UsS0FBZCxFQUFxQm9MLE1BQXJCLENBQVo7QUFDQTVHLG1CQUFTdkYsR0FBVCxFQUFjc0osT0FBZCxFQUF1Qm9CLFFBQXZCLEVBQWlDak4sQ0FBakM7QUFDRDs7QUFFRCxhQUFLa0YsUUFBTCxDQUFjO0FBQUEsaUJBQU87QUFDbkJvSCw2QkFBaUI0RjtBQURFLFdBQVA7QUFBQSxTQUFkO0FBR0Q7O0FBRUQ7Ozs7QUF4RFc7QUFBQTtBQUFBLDBDQTJEU2xTLENBM0RULEVBMkRZO0FBQUEsc0JBSWYsS0FBSzBELEtBSlU7QUFBQSxZQUNiSixLQURhLFdBQ2JBLEtBRGE7QUFBQSx3Q0FDTm1FLFNBRE07QUFBQSxZQUVuQk0sV0FGbUIscUJBRW5CQSxXQUZtQjtBQUFBLFlBR25CRSxhQUhtQixxQkFHbkJBLGFBSG1COztBQUtyQixZQUFNckYsV0FBVyxpQ0FBaUJVLEtBQWpCLEVBQXdCMkUsYUFBeEIsQ0FBakI7O0FBRUEsWUFBTXJJLFNBQVMsQ0FBQ2dELFFBQWhCOztBQUVBLFlBQU1zUCxlQUFldFMsU0FDbkIsK0JBQWUwRCxLQUFmLEVBQXNCMkUsYUFBdEIsQ0FEbUIsR0FFbkIsaUNBQWlCM0UsS0FBakIsRUFBd0IyRSxhQUF4QixDQUZGOztBQUtBM0UsY0FBTVYsUUFBTixHQUFpQnNQLFlBQWpCOztBQUVBLFlBQUluSyxXQUFKLEVBQWlCO0FBQ2ZBLHNCQUFZbkksTUFBWixFQUFvQixnQ0FBZ0IwRCxLQUFoQixDQUFwQixFQUE0Q3RELENBQTVDO0FBQ0Q7O0FBRUQsYUFBS2tGLFFBQUwsQ0FBYztBQUFBLGlCQUFPO0FBQ25Cb0gsNkJBQWlCNEY7QUFERSxXQUFQO0FBQUEsU0FBZDtBQUdEO0FBbEZVO0FBQUE7QUFBQSwrQkFvRkY7QUFDUCxlQUNFLDhCQUFDLElBQUQsZUFDTyxLQUFLeE8sS0FEWjtBQUVFLHVCQUFjLEtBQUtzTyxlQUZyQjtBQUdFLDJCQUFrQixLQUFLQztBQUh6QixXQURGO0FBT0Q7QUE1RlU7O0FBQUE7QUFBQSw4QkFFSmpMLFNBRkksR0FFUTtBQUNqQjFELFdBQU8sb0JBQVVpRSxNQUFWLENBQWlCTCxVQURQO0FBRWpCTyxlQUFXLG9CQUFVRixNQUFWLENBQWlCTDtBQUZYLEdBRlI7QUFBQSxDIiwiZmlsZSI6InJlYWN0LWJvb3RzdHJhcC10YWJsZTIvZGlzdC9yZWFjdC1ib290c3RyYXAtdGFibGUtbmV4dC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInJlYWN0XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlJlYWN0Qm9vdHN0cmFwVGFibGUyXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJlYWN0Qm9vdHN0cmFwVGFibGUyXCJdID0gZmFjdG9yeShyb290W1wiUmVhY3RcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gOCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYzU1ZDQ4YWY0OGU2YjNlNWY4YTAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJjb21tb25qc1wiOlwicmVhY3RcIixcImFtZFwiOlwicmVhY3RcIn1cbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImV4cG9ydCBkZWZhdWx0IHtcbiAgU09SVF9BU0M6ICdhc2MnLFxuICBTT1JUX0RFU0M6ICdkZXNjJyxcbiAgUk9XX1NFTEVDVF9TSU5HTEU6ICdyYWRpbycsXG4gIFJPV19TRUxFQ1RfTVVMVElQTEU6ICdjaGVja2JveCcsXG4gIFJPV19TRUxFQ1RfRElTQUJMRUQ6ICdST1dfU0VMRUNUX0RJU0FCTEVEJyxcbiAgQ0hFQ0tCT1hfU1RBVFVTX0NIRUNLRUQ6ICdjaGVja2VkJyxcbiAgQ0hFQ0tCT1hfU1RBVFVTX0lOREVURVJNSU5BVEU6ICdpbmRldGVybWluYXRlJyxcbiAgQ0hFQ0tCT1hfU1RBVFVTX1VOQ0hFQ0tFRDogJ3VuY2hlY2tlZCdcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb25zdC5qcyIsIi8qIGVzbGludCBuby1lbXB0eTogMCAqL1xuLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiAwICovXG4vKiBlc2xpbnQgcHJlZmVyLXJlc3QtcGFyYW1zOiAwICovXG5cbmZ1bmN0aW9uIHNwbGl0TmVzdGVkKHN0cikge1xuICByZXR1cm4gW3N0cl1cbiAgICAuam9pbignLicpXG4gICAgLnJlcGxhY2UoL1xcWy9nLCAnLicpXG4gICAgLnJlcGxhY2UoL1xcXS9nLCAnJylcbiAgICAuc3BsaXQoJy4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgZmllbGQpIHtcbiAgY29uc3QgcGF0aEFycmF5ID0gc3BsaXROZXN0ZWQoZmllbGQpO1xuICBsZXQgcmVzdWx0O1xuICB0cnkge1xuICAgIHJlc3VsdCA9IHBhdGhBcnJheS5yZWR1Y2UoKGN1cnIsIHBhdGgpID0+IGN1cnJbcGF0aF0sIHRhcmdldCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIGZpZWxkLCB2YWx1ZSwgc2FmZSA9IGZhbHNlKSB7XG4gIGNvbnN0IHBhdGhBcnJheSA9IHNwbGl0TmVzdGVkKGZpZWxkKTtcbiAgbGV0IGxldmVsID0gMDtcbiAgcGF0aEFycmF5LnJlZHVjZSgoYSwgYikgPT4ge1xuICAgIGxldmVsICs9IDE7XG4gICAgaWYgKHR5cGVvZiBhW2JdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKCFzYWZlKSB0aHJvdyBuZXcgRXJyb3IoYCR7YX0uJHtifSBpcyB1bmRlZmluZWRgKTtcbiAgICAgIGFbYl0gPSB7fTtcbiAgICAgIHJldHVybiBhW2JdO1xuICAgIH1cblxuICAgIGlmIChsZXZlbCA9PT0gcGF0aEFycmF5Lmxlbmd0aCkge1xuICAgICAgYVtiXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYVtiXTtcbiAgfSwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIE9iamVjdC4gdGhlIGBPYmplY3RgIGV4Y2VwdCBgRnVuY3Rpb25gIGFuZCBgQXJyYXkuYFxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGhlIHZhbHVlIGdvbm5hIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIG9iajtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlID09PSAnb2JqZWN0JyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBzbGVlcChmbiwgbXMpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gZm4oKSwgbXMpO1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgbGV0IHRpbWVvdXQ7XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBsYXRlciA9ICgpID0+IHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuXG4gICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG5cbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgfHwgMCk7XG5cbiAgICBpZiAoY2FsbE5vdykge1xuICAgICAgZnVuYy5hcHB5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldCxcbiAgc2V0LFxuICBpc0Z1bmN0aW9uLFxuICBpc09iamVjdCxcbiAgaXNFbXB0eU9iamVjdCxcbiAgaXNEZWZpbmVkLFxuICBzbGVlcCxcbiAgZGVib3VuY2Vcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy91dGlscy5qcyIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXG5leHBvcnQgY29uc3QgbWF0Y2hSb3cgPSAoa2V5RmllbGQsIGlkKSA9PiByb3cgPT4gcm93W2tleUZpZWxkXSA9PT0gaWQ7XG5cbmV4cG9ydCBjb25zdCBnZXRSb3dCeVJvd0lkID0gKHsgZGF0YSwga2V5RmllbGQgfSkgPT4gaWQgPT4gZGF0YS5maW5kKG1hdGNoUm93KGtleUZpZWxkLCBpZCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvcm93cy5qcyIsImltcG9ydCBfIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldFJvd0J5Um93SWQgfSBmcm9tICcuL3Jvd3MnO1xuXG5leHBvcnQgY29uc3QgaXNTZWxlY3RlZEFsbCA9ICh7IGRhdGEsIHNlbGVjdGVkIH0pID0+IGRhdGEubGVuZ3RoID09PSBzZWxlY3RlZC5sZW5ndGg7XG5cbmV4cG9ydCBjb25zdCBpc0FueVNlbGVjdGVkUm93ID0gKHsgc2VsZWN0ZWQgfSkgPT4gKHNraXBzID0gW10pID0+IHtcbiAgaWYgKHNraXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBzZWxlY3RlZC5sZW5ndGggPiAwO1xuICB9XG4gIHJldHVybiBzZWxlY3RlZC5maWx0ZXIoeCA9PiAhc2tpcHMuaW5jbHVkZXMoeCkpLmxlbmd0aDtcbn07XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RhYmxlS2V5cyA9ICh7IGRhdGEsIGtleUZpZWxkIH0pID0+IChza2lwcyA9IFtdKSA9PiB7XG4gIGlmIChza2lwcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZGF0YS5tYXAocm93ID0+IF8uZ2V0KHJvdywga2V5RmllbGQpKTtcbiAgfVxuICByZXR1cm4gZGF0YVxuICAgIC5maWx0ZXIocm93ID0+ICFza2lwcy5pbmNsdWRlcyhfLmdldChyb3csIGtleUZpZWxkKSkpXG4gICAgLm1hcChyb3cgPT4gXy5nZXQocm93LCBrZXlGaWVsZCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHVuU2VsZWN0YWJsZUtleXMgPSAoeyBzZWxlY3RlZCB9KSA9PiAoc2tpcHMgPSBbXSkgPT4ge1xuICBpZiAoc2tpcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBzZWxlY3RlZC5maWx0ZXIoeCA9PiBza2lwcy5pbmNsdWRlcyh4KSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2VsZWN0ZWRSb3dzID0gKHN0b3JlKSA9PiB7XG4gIGNvbnN0IGdldFJvdyA9IGdldFJvd0J5Um93SWQoc3RvcmUpO1xuICByZXR1cm4gc3RvcmUuc2VsZWN0ZWQubWFwKGsgPT4gZ2V0Um93KGspKTtcbn07XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL3NlbGVjdGlvbi5qcyIsImltcG9ydCBfIGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgRXh0ZW5kQmFzZSA9PlxuICBjbGFzcyBSZW1vdGVSZXNvbHZlciBleHRlbmRzIEV4dGVuZEJhc2Uge1xuICAgIGdldE5ld2VzdFN0YXRlKHN0YXRlID0ge30pIHtcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5zdG9yZSB8fCB0aGlzLnByb3BzLnN0b3JlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZTogc3RvcmUucGFnZSxcbiAgICAgICAgc2l6ZVBlclBhZ2U6IHN0b3JlLnNpemVQZXJQYWdlLFxuICAgICAgICBmaWx0ZXJzOiBzdG9yZS5maWx0ZXJzLFxuICAgICAgICBzb3J0RmllbGQ6IHN0b3JlLnNvcnRGaWVsZCxcbiAgICAgICAgc29ydE9yZGVyOiBzdG9yZS5zb3J0T3JkZXIsXG4gICAgICAgIGRhdGE6IHN0b3JlLmdldEFsbERhdGEoKSxcbiAgICAgICAgLi4uc3RhdGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaXNSZW1vdGVQYWdpbmF0aW9uKCkge1xuICAgICAgY29uc3QgeyByZW1vdGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gcmVtb3RlID09PSB0cnVlIHx8IChfLmlzT2JqZWN0KHJlbW90ZSkgJiYgcmVtb3RlLnBhZ2luYXRpb24pO1xuICAgIH1cblxuICAgIGlzUmVtb3RlRmlsdGVyaW5nKCkge1xuICAgICAgY29uc3QgeyByZW1vdGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gcmVtb3RlID09PSB0cnVlIHx8IChfLmlzT2JqZWN0KHJlbW90ZSkgJiYgcmVtb3RlLmZpbHRlcik7XG4gICAgfVxuXG4gICAgaXNSZW1vdGVTb3J0KCkge1xuICAgICAgY29uc3QgeyByZW1vdGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gcmVtb3RlID09PSB0cnVlIHx8IChfLmlzT2JqZWN0KHJlbW90ZSkgJiYgcmVtb3RlLnNvcnQpO1xuICAgIH1cblxuICAgIGlzUmVtb3RlQ2VsbEVkaXQoKSB7XG4gICAgICBjb25zdCB7IHJlbW90ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiByZW1vdGUgPT09IHRydWUgfHwgKF8uaXNPYmplY3QocmVtb3RlKSAmJiByZW1vdGUuY2VsbEVkaXQpO1xuICAgIH1cblxuICAgIGhhbmRsZVJlbW90ZVBhZ2VDaGFuZ2UoKSB7XG4gICAgICB0aGlzLnByb3BzLm9uVGFibGVDaGFuZ2UoJ3BhZ2luYXRpb24nLCB0aGlzLmdldE5ld2VzdFN0YXRlKCkpO1xuICAgIH1cblxuICAgIGhhbmRsZVJlbW90ZUZpbHRlckNoYW5nZSgpIHtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0ge307XG4gICAgICBpZiAodGhpcy5pc1JlbW90ZVBhZ2luYXRpb24oKSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5wcm9wcy5wYWdpbmF0aW9uLm9wdGlvbnMgfHwge307XG4gICAgICAgIG5ld1N0YXRlLnBhZ2UgPSBfLmlzRGVmaW5lZChvcHRpb25zLnBhZ2VTdGFydEluZGV4KSA/IG9wdGlvbnMucGFnZVN0YXJ0SW5kZXggOiAxO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9wcy5vblRhYmxlQ2hhbmdlKCdmaWx0ZXInLCB0aGlzLmdldE5ld2VzdFN0YXRlKG5ld1N0YXRlKSk7XG4gICAgfVxuXG4gICAgaGFuZGxlU29ydENoYW5nZSgpIHtcbiAgICAgIHRoaXMucHJvcHMub25UYWJsZUNoYW5nZSgnc29ydCcsIHRoaXMuZ2V0TmV3ZXN0U3RhdGUoKSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2VsbENoYW5nZShyb3dJZCwgZGF0YUZpZWxkLCBuZXdWYWx1ZSkge1xuICAgICAgY29uc3QgY2VsbEVkaXQgPSB7IHJvd0lkLCBkYXRhRmllbGQsIG5ld1ZhbHVlIH07XG4gICAgICB0aGlzLnByb3BzLm9uVGFibGVDaGFuZ2UoJ2NlbGxFZGl0JywgdGhpcy5nZXROZXdlc3RTdGF0ZSh7IGNlbGxFZGl0IH0pKTtcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9yZW1vdGUtcmVzb2x2ZXIuanMiLCJpbXBvcnQgQm9vdHN0cmFwVGFibGUgZnJvbSAnLi9zcmMvYm9vdHN0cmFwLXRhYmxlJztcbmltcG9ydCB3aXRoRGF0YVN0b3JlIGZyb20gJy4vc3JjL2NvbnRhaW5lcic7XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhEYXRhU3RvcmUoQm9vdHN0cmFwVGFibGUpO1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL2luZGV4LmpzIiwiLyogZXNsaW50IGFycm93LWJvZHktc3R5bGU6IDAgKi9cblxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3MgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCBIZWFkZXIgZnJvbSAnLi9oZWFkZXInO1xuaW1wb3J0IENhcHRpb24gZnJvbSAnLi9jYXB0aW9uJztcbmltcG9ydCBCb2R5IGZyb20gJy4vYm9keSc7XG5pbXBvcnQgUHJvcHNCYXNlUmVzb2x2ZXIgZnJvbSAnLi9wcm9wcy1yZXNvbHZlcic7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9jb25zdCc7XG5pbXBvcnQgeyBpc1NlbGVjdGVkQWxsIH0gZnJvbSAnLi9zdG9yZS9zZWxlY3Rpb24nO1xuXG5jbGFzcyBCb290c3RyYXBUYWJsZSBleHRlbmRzIFByb3BzQmFzZVJlc29sdmVyKENvbXBvbmVudCkge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnZhbGlkYXRlUHJvcHMoKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBkYXRhOiBwcm9wcy5kYXRhXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkYXRhOiBuZXh0UHJvcHMuZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgbG9hZGluZywgb3ZlcmxheSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucmVuZGVyVGFibGUoKTtcbiAgICBpZiAobG9hZGluZyAmJiBvdmVybGF5KSB7XG4gICAgICBjb25zdCBMb2FkaW5nT3ZlcmxheSA9IG92ZXJsYXkodGFibGUsIGxvYWRpbmcpO1xuICAgICAgcmV0dXJuIDxMb2FkaW5nT3ZlcmxheSAvPjtcbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG5cbiAgcmVuZGVyVGFibGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RvcmUsXG4gICAgICBjb2x1bW5zLFxuICAgICAga2V5RmllbGQsXG4gICAgICBpZCxcbiAgICAgIGNsYXNzZXMsXG4gICAgICBzdHJpcGVkLFxuICAgICAgaG92ZXIsXG4gICAgICBib3JkZXJlZCxcbiAgICAgIGNvbmRlbnNlZCxcbiAgICAgIG5vRGF0YUluZGljYXRpb24sXG4gICAgICBjYXB0aW9uLFxuICAgICAgcm93U3R5bGUsXG4gICAgICByb3dDbGFzc2VzLFxuICAgICAgcm93RXZlbnRzXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB0YWJsZUNsYXNzID0gY3MoJ3RhYmxlJywge1xuICAgICAgJ3RhYmxlLXN0cmlwZWQnOiBzdHJpcGVkLFxuICAgICAgJ3RhYmxlLWhvdmVyJzogaG92ZXIsXG4gICAgICAndGFibGUtYm9yZGVyZWQnOiBib3JkZXJlZCxcbiAgICAgICd0YWJsZS1jb25kZW5zZWQnOiBjb25kZW5zZWRcbiAgICB9LCBjbGFzc2VzKTtcblxuICAgIGNvbnN0IGNlbGxTZWxlY3Rpb25JbmZvID0gdGhpcy5yZXNvbHZlU2VsZWN0Um93UHJvcHMoe1xuICAgICAgb25Sb3dTZWxlY3Q6IHRoaXMucHJvcHMub25Sb3dTZWxlY3RcbiAgICB9KTtcblxuICAgIGNvbnN0IGhlYWRlckNlbGxTZWxlY3Rpb25JbmZvID0gdGhpcy5yZXNvbHZlU2VsZWN0Um93UHJvcHNGb3JIZWFkZXIoe1xuICAgICAgb25BbGxSb3dzU2VsZWN0OiB0aGlzLnByb3BzLm9uQWxsUm93c1NlbGVjdCxcbiAgICAgIHNlbGVjdGVkOiBzdG9yZS5zZWxlY3RlZCxcbiAgICAgIGFsbFJvd3NTZWxlY3RlZDogaXNTZWxlY3RlZEFsbChzdG9yZSlcbiAgICB9KTtcblxuICAgIGNvbnN0IHRhYmxlQ2FwdGlvbiA9IChjYXB0aW9uICYmIDxDYXB0aW9uPnsgY2FwdGlvbiB9PC9DYXB0aW9uPik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWFjdC1ib290c3RyYXAtdGFibGVcIj5cbiAgICAgICAgPHRhYmxlIGlkPXsgaWQgfSBjbGFzc05hbWU9eyB0YWJsZUNsYXNzIH0+XG4gICAgICAgICAgeyB0YWJsZUNhcHRpb24gfVxuICAgICAgICAgIDxIZWFkZXJcbiAgICAgICAgICAgIGNvbHVtbnM9eyBjb2x1bW5zIH1cbiAgICAgICAgICAgIHNvcnRGaWVsZD17IHN0b3JlLnNvcnRGaWVsZCB9XG4gICAgICAgICAgICBzb3J0T3JkZXI9eyBzdG9yZS5zb3J0T3JkZXIgfVxuICAgICAgICAgICAgb25Tb3J0PXsgdGhpcy5wcm9wcy5vblNvcnQgfVxuICAgICAgICAgICAgb25GaWx0ZXI9eyB0aGlzLnByb3BzLm9uRmlsdGVyIH1cbiAgICAgICAgICAgIHNlbGVjdFJvdz17IGhlYWRlckNlbGxTZWxlY3Rpb25JbmZvIH1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxCb2R5XG4gICAgICAgICAgICBkYXRhPXsgdGhpcy5zdGF0ZS5kYXRhIH1cbiAgICAgICAgICAgIGtleUZpZWxkPXsga2V5RmllbGQgfVxuICAgICAgICAgICAgY29sdW1ucz17IGNvbHVtbnMgfVxuICAgICAgICAgICAgaXNFbXB0eT17IHRoaXMuaXNFbXB0eSgpIH1cbiAgICAgICAgICAgIHZpc2libGVDb2x1bW5TaXplPXsgdGhpcy52aXNpYmxlQ29sdW1uU2l6ZSgpIH1cbiAgICAgICAgICAgIG5vRGF0YUluZGljYXRpb249eyBub0RhdGFJbmRpY2F0aW9uIH1cbiAgICAgICAgICAgIGNlbGxFZGl0PXsgdGhpcy5wcm9wcy5jZWxsRWRpdCB8fCB7fSB9XG4gICAgICAgICAgICBzZWxlY3RSb3c9eyBjZWxsU2VsZWN0aW9uSW5mbyB9XG4gICAgICAgICAgICBzZWxlY3RlZFJvd0tleXM9eyBzdG9yZS5zZWxlY3RlZCB9XG4gICAgICAgICAgICByb3dTdHlsZT17IHJvd1N0eWxlIH1cbiAgICAgICAgICAgIHJvd0NsYXNzZXM9eyByb3dDbGFzc2VzIH1cbiAgICAgICAgICAgIHJvd0V2ZW50cz17IHJvd0V2ZW50cyB9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC90YWJsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuQm9vdHN0cmFwVGFibGUucHJvcFR5cGVzID0ge1xuICBrZXlGaWVsZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHJlbW90ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgcGFnaW5hdGlvbjogUHJvcFR5cGVzLmJvb2xcbiAgfSldKSxcbiAgc3RvcmU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG5vRGF0YUluZGljYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gIHN0cmlwZWQ6IFByb3BUeXBlcy5ib29sLFxuICBib3JkZXJlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGhvdmVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNvbmRlbnNlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGNhcHRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5ub2RlLFxuICAgIFByb3BUeXBlcy5zdHJpbmdcbiAgXSksXG4gIHBhZ2luYXRpb246IFByb3BUeXBlcy5vYmplY3QsXG4gIGZpbHRlcjogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2VsbEVkaXQ6IFByb3BUeXBlcy5vYmplY3QsXG4gIHNlbGVjdFJvdzogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBtb2RlOiBQcm9wVHlwZXMub25lT2YoW0NvbnN0LlJPV19TRUxFQ1RfU0lOR0xFLCBDb25zdC5ST1dfU0VMRUNUX01VTFRJUExFXSkuaXNSZXF1aXJlZCxcbiAgICBjbGlja1RvU2VsZWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBjbGlja1RvRWRpdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2VsZWN0QWxsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBjbGFzc2VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIG5vblNlbGVjdGFibGU6IFByb3BUeXBlcy5hcnJheSxcbiAgICBiZ0NvbG9yOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGhpZGVTZWxlY3RDb2x1bW46IFByb3BUeXBlcy5ib29sXG4gIH0pLFxuICBvblJvd1NlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQWxsUm93c1NlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIHJvd1N0eWxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLFxuICByb3dFdmVudHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIHJvd0NsYXNzZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gIGRlZmF1bHRTb3J0ZWQ6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZGF0YUZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgb3JkZXI6IFByb3BUeXBlcy5vbmVPZihbQ29uc3QuU09SVF9ERVNDLCBDb25zdC5TT1JUX0FTQ10pLmlzUmVxdWlyZWRcbiAgfSkpLFxuICBkZWZhdWx0U29ydERpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtDb25zdC5TT1JUX0RFU0MsIENvbnN0LlNPUlRfQVNDXSksXG4gIG92ZXJsYXk6IFByb3BUeXBlcy5mdW5jLFxuICBvblRhYmxlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Tb3J0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5Cb290c3RyYXBUYWJsZS5kZWZhdWx0UHJvcHMgPSB7XG4gIHJlbW90ZTogZmFsc2UsXG4gIHN0cmlwZWQ6IGZhbHNlLFxuICBib3JkZXJlZDogdHJ1ZSxcbiAgaG92ZXI6IGZhbHNlLFxuICBjb25kZW5zZWQ6IGZhbHNlLFxuICBub0RhdGFJbmRpY2F0aW9uOiBudWxsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCb290c3RyYXBUYWJsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2Jvb3RzdHJhcC10YWJsZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiBlc2xpbnQgcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzOiAwICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDb25zdCBmcm9tICcuL2NvbnN0JztcblxuaW1wb3J0IEhlYWRlckNlbGwgZnJvbSAnLi9oZWFkZXItY2VsbCc7XG5pbXBvcnQgU2VsZWN0aW9uSGVhZGVyQ2VsbCBmcm9tICcuL3Jvdy1zZWxlY3Rpb24vc2VsZWN0aW9uLWhlYWRlci1jZWxsJztcblxuY29uc3QgSGVhZGVyID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgUk9XX1NFTEVDVF9ESVNBQkxFRCB9ID0gQ29uc3Q7XG5cbiAgY29uc3Qge1xuICAgIGNvbHVtbnMsXG4gICAgb25Tb3J0LFxuICAgIG9uRmlsdGVyLFxuICAgIHNvcnRGaWVsZCxcbiAgICBzb3J0T3JkZXIsXG4gICAgc2VsZWN0Um93XG4gIH0gPSBwcm9wcztcblxuICByZXR1cm4gKFxuICAgIDx0aGVhZD5cbiAgICAgIDx0cj5cbiAgICAgICAge1xuICAgICAgICAgIChzZWxlY3RSb3cubW9kZSAhPT0gUk9XX1NFTEVDVF9ESVNBQkxFRCAmJiAhc2VsZWN0Um93LmhpZGVTZWxlY3RDb2x1bW4pXG4gICAgICAgICAgICA/IDxTZWxlY3Rpb25IZWFkZXJDZWxsIHsgLi4uc2VsZWN0Um93IH0gLz4gOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIGNvbHVtbnMubWFwKChjb2x1bW4sIGkpID0+IHtcbiAgICAgICAgICAgIGlmICghY29sdW1uLmhpZGRlbikge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyU29ydCA9IGNvbHVtbi5kYXRhRmllbGQgPT09IHNvcnRGaWVsZDtcbiAgICAgICAgICAgICAgY29uc3QgaXNMYXN0U29ydGluZyA9IGNvbHVtbi5kYXRhRmllbGQgPT09IHNvcnRGaWVsZDtcblxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxIZWFkZXJDZWxsXG4gICAgICAgICAgICAgICAgICBpbmRleD17IGkgfVxuICAgICAgICAgICAgICAgICAga2V5PXsgY29sdW1uLmRhdGFGaWVsZCB9XG4gICAgICAgICAgICAgICAgICBjb2x1bW49eyBjb2x1bW4gfVxuICAgICAgICAgICAgICAgICAgb25Tb3J0PXsgb25Tb3J0IH1cbiAgICAgICAgICAgICAgICAgIHNvcnRpbmc9eyBjdXJyU29ydCB9XG4gICAgICAgICAgICAgICAgICBvbkZpbHRlcj17IG9uRmlsdGVyIH1cbiAgICAgICAgICAgICAgICAgIHNvcnRPcmRlcj17IHNvcnRPcmRlciB9XG4gICAgICAgICAgICAgICAgICBpc0xhc3RTb3J0aW5nPXsgaXNMYXN0U29ydGluZyB9XG4gICAgICAgICAgICAgICAgLz4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIDwvdHI+XG4gICAgPC90aGVhZD5cbiAgKTtcbn07XG5cbkhlYWRlci5wcm9wVHlwZXMgPSB7XG4gIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBvblNvcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbkZpbHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvcnRGaWVsZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgc29ydE9yZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzZWxlY3RSb3c6IFByb3BUeXBlcy5vYmplY3Rcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2hlYWRlci5qcyIsIi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3MgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9jb25zdCc7XG5pbXBvcnQgU29ydFN5bWJvbCBmcm9tICcuL3NvcnQvc3ltYm9sJztcbmltcG9ydCBTb3J0Q2FyZXQgZnJvbSAnLi9zb3J0L2NhcmV0JztcbmltcG9ydCBfIGZyb20gJy4vdXRpbHMnO1xuXG5cbmNvbnN0IEhlYWRlckNlbGwgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbHVtbixcbiAgICBpbmRleCxcbiAgICBvblNvcnQsXG4gICAgc29ydGluZyxcbiAgICBzb3J0T3JkZXIsXG4gICAgaXNMYXN0U29ydGluZyxcbiAgICBvbkZpbHRlclxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3Qge1xuICAgIHRleHQsXG4gICAgc29ydCxcbiAgICBmaWx0ZXIsXG4gICAgaGVhZGVyVGl0bGUsXG4gICAgaGVhZGVyQWxpZ24sXG4gICAgaGVhZGVyRm9ybWF0dGVyLFxuICAgIGhlYWRlckV2ZW50cyxcbiAgICBoZWFkZXJDbGFzc2VzLFxuICAgIGhlYWRlclN0eWxlLFxuICAgIGhlYWRlckF0dHJzLFxuICAgIGhlYWRlclNvcnRpbmdDbGFzc2VzLFxuICAgIGhlYWRlclNvcnRpbmdTdHlsZVxuICB9ID0gY29sdW1uO1xuXG4gIGNvbnN0IGNlbGxBdHRycyA9IHtcbiAgICAuLi5fLmlzRnVuY3Rpb24oaGVhZGVyQXR0cnMpID8gaGVhZGVyQXR0cnMoY29sdW1uLCBpbmRleCkgOiBoZWFkZXJBdHRycyxcbiAgICAuLi5oZWFkZXJFdmVudHNcbiAgfTtcblxuICBsZXQgc29ydFN5bWJvbDtcbiAgbGV0IGZpbHRlckVsbTtcbiAgbGV0IGNlbGxTdHlsZSA9IHt9O1xuICBsZXQgY2VsbENsYXNzZXMgPSBfLmlzRnVuY3Rpb24oaGVhZGVyQ2xhc3NlcykgPyBoZWFkZXJDbGFzc2VzKGNvbHVtbiwgaW5kZXgpIDogaGVhZGVyQ2xhc3NlcztcblxuICBpZiAoaGVhZGVyU3R5bGUpIHtcbiAgICBjZWxsU3R5bGUgPSBfLmlzRnVuY3Rpb24oaGVhZGVyU3R5bGUpID8gaGVhZGVyU3R5bGUoY29sdW1uLCBpbmRleCkgOiBoZWFkZXJTdHlsZTtcbiAgfVxuXG4gIGlmIChoZWFkZXJUaXRsZSkge1xuICAgIGNlbGxBdHRycy50aXRsZSA9IF8uaXNGdW5jdGlvbihoZWFkZXJUaXRsZSkgPyBoZWFkZXJUaXRsZShjb2x1bW4sIGluZGV4KSA6IHRleHQ7XG4gIH1cblxuICBpZiAoaGVhZGVyQWxpZ24pIHtcbiAgICBjZWxsU3R5bGUudGV4dEFsaWduID0gXy5pc0Z1bmN0aW9uKGhlYWRlckFsaWduKSA/IGhlYWRlckFsaWduKGNvbHVtbiwgaW5kZXgpIDogaGVhZGVyQWxpZ247XG4gIH1cblxuICBpZiAoc29ydCkge1xuICAgIGNvbnN0IGN1c3RvbUNsaWNrID0gY2VsbEF0dHJzLm9uQ2xpY2s7XG4gICAgY2VsbEF0dHJzLm9uQ2xpY2sgPSAoZSkgPT4ge1xuICAgICAgb25Tb3J0KGNvbHVtbik7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKGN1c3RvbUNsaWNrKSkgY3VzdG9tQ2xpY2soZSk7XG4gICAgfTtcbiAgICBjZWxsQXR0cnMuY2xhc3NOYW1lID0gY3MoY2VsbEF0dHJzLmNsYXNzTmFtZSwgJ3NvcnRhYmxlJyk7XG5cbiAgICBpZiAoc29ydGluZykge1xuICAgICAgc29ydFN5bWJvbCA9IDxTb3J0Q2FyZXQgb3JkZXI9eyBzb3J0T3JkZXIgfSAvPjtcblxuICAgICAgLy8gYXBwZW5kIGN1c3RvbWl6ZWQgY2xhc3NlcyBvciBzdHlsZSBpZiB0YWJsZSB3YXMgc29ydGluZyBiYXNlZCBvbiB0aGUgY3VycmVudCBjb2x1bW4uXG4gICAgICBjZWxsQ2xhc3NlcyA9IGNzKFxuICAgICAgICBjZWxsQ2xhc3NlcyxcbiAgICAgICAgXy5pc0Z1bmN0aW9uKGhlYWRlclNvcnRpbmdDbGFzc2VzKVxuICAgICAgICAgID8gaGVhZGVyU29ydGluZ0NsYXNzZXMoY29sdW1uLCBzb3J0T3JkZXIsIGlzTGFzdFNvcnRpbmcsIGluZGV4KVxuICAgICAgICAgIDogaGVhZGVyU29ydGluZ0NsYXNzZXNcbiAgICAgICk7XG5cbiAgICAgIGNlbGxTdHlsZSA9IHtcbiAgICAgICAgLi4uY2VsbFN0eWxlLFxuICAgICAgICAuLi5fLmlzRnVuY3Rpb24oaGVhZGVyU29ydGluZ1N0eWxlKVxuICAgICAgICAgID8gaGVhZGVyU29ydGluZ1N0eWxlKGNvbHVtbiwgc29ydE9yZGVyLCBpc0xhc3RTb3J0aW5nLCBpbmRleClcbiAgICAgICAgICA6IGhlYWRlclNvcnRpbmdTdHlsZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ydFN5bWJvbCA9IDxTb3J0U3ltYm9sIC8+O1xuICAgIH1cbiAgfVxuXG4gIGlmIChjZWxsQ2xhc3NlcykgY2VsbEF0dHJzLmNsYXNzTmFtZSA9IGNzKGNlbGxBdHRycy5jbGFzc05hbWUsIGNlbGxDbGFzc2VzKTtcbiAgaWYgKCFfLmlzRW1wdHlPYmplY3QoY2VsbFN0eWxlKSkgY2VsbEF0dHJzLnN0eWxlID0gY2VsbFN0eWxlO1xuICBpZiAoZmlsdGVyKSB7XG4gICAgZmlsdGVyRWxtID0gPGZpbHRlci5GaWx0ZXIgeyAuLi5maWx0ZXIucHJvcHMgfSBvbkZpbHRlcj17IG9uRmlsdGVyIH0gY29sdW1uPXsgY29sdW1uIH0gLz47XG4gIH1cblxuICBjb25zdCBjaGlsZHJlbiA9IGhlYWRlckZvcm1hdHRlciA/XG4gICAgaGVhZGVyRm9ybWF0dGVyKGNvbHVtbiwgaW5kZXgsIHsgc29ydEVsZW1lbnQ6IHNvcnRTeW1ib2wsIGZpbHRlckVsZW1lbnQ6IGZpbHRlckVsbSB9KSA6XG4gICAgdGV4dDtcblxuICBpZiAoaGVhZGVyRm9ybWF0dGVyKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3RoJywgY2VsbEF0dHJzLCBjaGlsZHJlbik7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgndGgnLCBjZWxsQXR0cnMsIGNoaWxkcmVuLCBzb3J0U3ltYm9sLCBmaWx0ZXJFbG0pO1xufTtcblxuSGVhZGVyQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIGNvbHVtbjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBkYXRhRmllbGQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICB0ZXh0OiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgaGlkZGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBoZWFkZXJGb3JtYXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIGZvcm1hdHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZm9ybWF0RXh0cmFEYXRhOiBQcm9wVHlwZXMuYW55LFxuICAgIGhlYWRlckNsYXNzZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgY2xhc3NlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBoZWFkZXJTdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBzdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBoZWFkZXJUaXRsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgdGl0bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGhlYWRlckV2ZW50czogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBldmVudHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgaGVhZGVyQWxpZ246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgaGVhZGVyQXR0cnM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgYXR0cnM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgc29ydDogUHJvcFR5cGVzLmJvb2wsXG4gICAgc29ydEZ1bmM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uU29ydDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZWRpdGFibGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGVkaXRDZWxsU3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgZWRpdENlbGxDbGFzc2VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGVkaXRvclN0eWxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGVkaXRvckNsYXNzZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgdmFsaWRhdG9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBmaWx0ZXI6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgZmlsdGVyVmFsdWU6IFByb3BUeXBlcy5mdW5jXG4gIH0pLmlzUmVxdWlyZWQsXG4gIGluZGV4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uU29ydDogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvcnRpbmc6IFByb3BUeXBlcy5ib29sLFxuICBzb3J0T3JkZXI6IFByb3BUeXBlcy5vbmVPZihbQ29uc3QuU09SVF9BU0MsIENvbnN0LlNPUlRfREVTQ10pLFxuICBpc0xhc3RTb3J0aW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5leHBvcnQgZGVmYXVsdCBIZWFkZXJDZWxsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvaGVhZGVyLWNlbGwuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBTb3J0U3ltYm9sID0gKCkgPT4gKFxuICA8c3BhbiBjbGFzc05hbWU9XCJvcmRlclwiPlxuICAgIDxzcGFuIGNsYXNzTmFtZT1cImRyb3Bkb3duXCI+XG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJjYXJldFwiIC8+XG4gICAgPC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzTmFtZT1cImRyb3B1cFwiPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiY2FyZXRcIiAvPlxuICAgIDwvc3Bhbj5cbiAgPC9zcGFuPik7XG5cbmV4cG9ydCBkZWZhdWx0IFNvcnRTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zb3J0L3N5bWJvbC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3MgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuXG5jb25zdCBTb3J0Q2FyZXQgPSAoeyBvcmRlciB9KSA9PiB7XG4gIGNvbnN0IG9yZGVyQ2xhc3MgPSBjcygncmVhY3QtYm9vdHN0cmFwLXRhYmxlLXNvcnQtb3JkZXInLCB7XG4gICAgZHJvcHVwOiBvcmRlciA9PT0gQ29uc3QuU09SVF9BU0NcbiAgfSk7XG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPXsgb3JkZXJDbGFzcyB9PlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiY2FyZXRcIiAvPlxuICAgIDwvc3Bhbj5cbiAgKTtcbn07XG5cblNvcnRDYXJldC5wcm9wVHlwZXMgPSB7XG4gIG9yZGVyOiBQcm9wVHlwZXMub25lT2YoW0NvbnN0LlNPUlRfQVNDLCBDb25zdC5TT1JUX0RFU0NdKS5pc1JlcXVpcmVkXG59O1xuZXhwb3J0IGRlZmF1bHQgU29ydENhcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc29ydC9jYXJldC5qcyIsIi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4uL2NvbnN0JztcblxuZXhwb3J0IGNvbnN0IENoZWNrQm94ID0gKHsgY2hlY2tlZCwgaW5kZXRlcm1pbmF0ZSB9KSA9PiAoXG4gIDxpbnB1dFxuICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgY2hlY2tlZD17IGNoZWNrZWQgfVxuICAgIHJlZj17IChpbnB1dCkgPT4ge1xuICAgICAgaWYgKGlucHV0KSBpbnB1dC5pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIH0gfVxuICAvPlxuKTtcblxuQ2hlY2tCb3gucHJvcFR5cGVzID0ge1xuICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICBpbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3Rpb25IZWFkZXJDZWxsIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBtb2RlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgY2hlY2tlZFN0YXR1czogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkFsbFJvd3NTZWxlY3Q6IFByb3BUeXBlcy5mdW5jXG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaGFuZGxlQ2hlY2tCb3hDbGljayA9IHRoaXMuaGFuZGxlQ2hlY2tCb3hDbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGF2b2lkIHVwZGF0aW5nIGlmIGJ1dHRvbiBpc1xuICAgKiAxLiByYWRpb1xuICAgKiAyLiBzdGF0dXMgd2FzIG5vdCBjaGFuZ2VkLlxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgIGNvbnN0IHsgUk9XX1NFTEVDVF9TSU5HTEUgfSA9IENvbnN0O1xuICAgIGNvbnN0IHsgbW9kZSwgY2hlY2tlZFN0YXR1cyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChtb2RlID09PSBST1dfU0VMRUNUX1NJTkdMRSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIG5leHRQcm9wcy5jaGVja2VkU3RhdHVzICE9PSBjaGVja2VkU3RhdHVzO1xuICB9XG5cbiAgaGFuZGxlQ2hlY2tCb3hDbGljayhlKSB7XG4gICAgY29uc3QgeyBvbkFsbFJvd3NTZWxlY3QgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBvbkFsbFJvd3NTZWxlY3QoZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgQ0hFQ0tCT1hfU1RBVFVTX0NIRUNLRUQsIENIRUNLQk9YX1NUQVRVU19JTkRFVEVSTUlOQVRFLCBST1dfU0VMRUNUX1NJTkdMRVxuICAgIH0gPSBDb25zdDtcblxuICAgIGNvbnN0IHsgbW9kZSwgY2hlY2tlZFN0YXR1cyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGNoZWNrZWQgPSBjaGVja2VkU3RhdHVzID09PSBDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRDtcblxuICAgIGNvbnN0IGluZGV0ZXJtaW5hdGUgPSBjaGVja2VkU3RhdHVzID09PSBDSEVDS0JPWF9TVEFUVVNfSU5ERVRFUk1JTkFURTtcblxuICAgIHJldHVybiBtb2RlID09PSBST1dfU0VMRUNUX1NJTkdMRVxuICAgICAgPyA8dGggZGF0YS1yb3ctc2VsZWN0aW9uIC8+XG4gICAgICA6IChcbiAgICAgICAgPHRoIGRhdGEtcm93LXNlbGVjdGlvbiBvbkNsaWNrPXsgdGhpcy5oYW5kbGVDaGVja0JveENsaWNrIH0+XG4gICAgICAgICAgPENoZWNrQm94XG4gICAgICAgICAgICB7IC4uLnRoaXMucHJvcHMgfVxuICAgICAgICAgICAgY2hlY2tlZD17IGNoZWNrZWQgfVxuICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZT17IGluZGV0ZXJtaW5hdGUgfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvdGg+XG4gICAgICApO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctc2VsZWN0aW9uL3NlbGVjdGlvbi1oZWFkZXItY2VsbC5qcyIsIi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jb25zdCBDYXB0aW9uID0gKHByb3BzKSA9PiB7XG4gIGlmICghcHJvcHMuY2hpbGRyZW4pIHJldHVybiBudWxsO1xuICByZXR1cm4gKFxuICAgIDxjYXB0aW9uPnsgcHJvcHMuY2hpbGRyZW4gfTwvY2FwdGlvbj5cbiAgKTtcbn07XG5cbkNhcHRpb24ucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLm5vZGUsXG4gICAgUHJvcFR5cGVzLnN0cmluZ1xuICBdKVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FwdGlvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2NhcHRpb24uanMiLCIvKiBlc2xpbnQgcmVhY3QvcHJvcC10eXBlczogMCAqL1xuLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcyBmcm9tICdjbGFzc25hbWVzJztcblxuaW1wb3J0IF8gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgUm93IGZyb20gJy4vcm93JztcbmltcG9ydCBSb3dTZWN0aW9uIGZyb20gJy4vcm93LXNlY3Rpb24nO1xuaW1wb3J0IENvbnN0IGZyb20gJy4vY29uc3QnO1xuXG5jb25zdCBCb2R5ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb2x1bW5zLFxuICAgIGRhdGEsXG4gICAga2V5RmllbGQsXG4gICAgaXNFbXB0eSxcbiAgICBub0RhdGFJbmRpY2F0aW9uLFxuICAgIHZpc2libGVDb2x1bW5TaXplLFxuICAgIGNlbGxFZGl0LFxuICAgIHNlbGVjdFJvdyxcbiAgICBzZWxlY3RlZFJvd0tleXMsXG4gICAgcm93U3R5bGUsXG4gICAgcm93Q2xhc3NlcyxcbiAgICByb3dFdmVudHNcbiAgfSA9IHByb3BzO1xuXG4gIGNvbnN0IHtcbiAgICBiZ0NvbG9yLFxuICAgIG5vblNlbGVjdGFibGVcbiAgfSA9IHNlbGVjdFJvdztcblxuICBsZXQgY29udGVudDtcblxuICBpZiAoaXNFbXB0eSkge1xuICAgIGNvbnN0IGluZGljYXRpb24gPSBfLmlzRnVuY3Rpb24obm9EYXRhSW5kaWNhdGlvbikgPyBub0RhdGFJbmRpY2F0aW9uKCkgOiBub0RhdGFJbmRpY2F0aW9uO1xuICAgIGlmICghaW5kaWNhdGlvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnRlbnQgPSA8Um93U2VjdGlvbiBjb250ZW50PXsgaW5kaWNhdGlvbiB9IGNvbFNwYW49eyB2aXNpYmxlQ29sdW1uU2l6ZSB9IC8+O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vbkVkaXRhYmxlUm93cyA9IGNlbGxFZGl0Lm5vbkVkaXRhYmxlUm93cyB8fCBbXTtcbiAgICBjb250ZW50ID0gZGF0YS5tYXAoKHJvdywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IF8uZ2V0KHJvdywga2V5RmllbGQpO1xuICAgICAgY29uc3QgZWRpdGFibGUgPSAhKG5vbkVkaXRhYmxlUm93cy5sZW5ndGggPiAwICYmIG5vbkVkaXRhYmxlUm93cy5pbmRleE9mKGtleSkgPiAtMSk7XG5cbiAgICAgIGNvbnN0IHNlbGVjdGVkID0gc2VsZWN0Um93Lm1vZGUgIT09IENvbnN0LlJPV19TRUxFQ1RfRElTQUJMRURcbiAgICAgICAgPyBzZWxlY3RlZFJvd0tleXMuaW5jbHVkZXMoa2V5KVxuICAgICAgICA6IG51bGw7XG5cbiAgICAgIGNvbnN0IGF0dHJzID0gcm93RXZlbnRzIHx8IHt9O1xuICAgICAgbGV0IHN0eWxlID0gXy5pc0Z1bmN0aW9uKHJvd1N0eWxlKSA/IHJvd1N0eWxlKHJvdywgaW5kZXgpIDogcm93U3R5bGU7XG4gICAgICBsZXQgY2xhc3NlcyA9IChfLmlzRnVuY3Rpb24ocm93Q2xhc3NlcykgPyByb3dDbGFzc2VzKHJvdywgaW5kZXgpIDogcm93Q2xhc3Nlcyk7XG4gICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRTdHlsZSA9IF8uaXNGdW5jdGlvbihzZWxlY3RSb3cuc3R5bGUpXG4gICAgICAgICAgPyBzZWxlY3RSb3cuc3R5bGUocm93LCBpbmRleClcbiAgICAgICAgICA6IHNlbGVjdFJvdy5zdHlsZTtcblxuICAgICAgICBjb25zdCBzZWxlY3RlZENsYXNzZXMgPSBfLmlzRnVuY3Rpb24oc2VsZWN0Um93LmNsYXNzZXMpXG4gICAgICAgICAgPyBzZWxlY3RSb3cuY2xhc3Nlcyhyb3csIGluZGV4KVxuICAgICAgICAgIDogc2VsZWN0Um93LmNsYXNzZXM7XG5cbiAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgLi4uc2VsZWN0ZWRTdHlsZVxuICAgICAgICB9O1xuICAgICAgICBjbGFzc2VzID0gY3MoY2xhc3Nlcywgc2VsZWN0ZWRDbGFzc2VzKTtcblxuICAgICAgICBpZiAoYmdDb2xvcikge1xuICAgICAgICAgIHN0eWxlID0gc3R5bGUgfHwge307XG4gICAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXy5pc0Z1bmN0aW9uKGJnQ29sb3IpID8gYmdDb2xvcihyb3csIGluZGV4KSA6IGJnQ29sb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsZWN0YWJsZSA9ICFub25TZWxlY3RhYmxlIHx8ICFub25TZWxlY3RhYmxlLmluY2x1ZGVzKGtleSk7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxSb3dcbiAgICAgICAgICBrZXk9eyBrZXkgfVxuICAgICAgICAgIHJvdz17IHJvdyB9XG4gICAgICAgICAga2V5RmllbGQ9eyBrZXlGaWVsZCB9XG4gICAgICAgICAgcm93SW5kZXg9eyBpbmRleCB9XG4gICAgICAgICAgY29sdW1ucz17IGNvbHVtbnMgfVxuICAgICAgICAgIGNlbGxFZGl0PXsgY2VsbEVkaXQgfVxuICAgICAgICAgIGVkaXRhYmxlPXsgZWRpdGFibGUgfVxuICAgICAgICAgIHNlbGVjdGFibGU9eyBzZWxlY3RhYmxlIH1cbiAgICAgICAgICBzZWxlY3RlZD17IHNlbGVjdGVkIH1cbiAgICAgICAgICBzZWxlY3RSb3c9eyBzZWxlY3RSb3cgfVxuICAgICAgICAgIHN0eWxlPXsgc3R5bGUgfVxuICAgICAgICAgIGNsYXNzTmFtZT17IGNsYXNzZXMgfVxuICAgICAgICAgIGF0dHJzPXsgYXR0cnMgfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPHRib2R5PnsgY29udGVudCB9PC90Ym9keT5cbiAgKTtcbn07XG5cbkJvZHkucHJvcFR5cGVzID0ge1xuICBrZXlGaWVsZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHNlbGVjdFJvdzogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2VsZWN0ZWRSb3dLZXlzOiBQcm9wVHlwZXMuYXJyYXlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJvZHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9ib2R5LmpzIiwiLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbi8qIGVzbGludCByZWFjdC9uby1hcnJheS1pbmRleC1rZXk6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgXyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBDZWxsIGZyb20gJy4vY2VsbCc7XG5pbXBvcnQgU2VsZWN0aW9uQ2VsbCBmcm9tICcuL3Jvdy1zZWxlY3Rpb24vc2VsZWN0aW9uLWNlbGwnO1xuaW1wb3J0IGV2ZW50RGVsZWdhdGVyIGZyb20gJy4vcm93LWV2ZW50LWRlbGVnYXRlcic7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9jb25zdCc7XG5cbmNsYXNzIFJvdyBleHRlbmRzIGV2ZW50RGVsZWdhdGVyKENvbXBvbmVudCkge1xuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcm93LFxuICAgICAgY29sdW1ucyxcbiAgICAgIGtleUZpZWxkLFxuICAgICAgcm93SW5kZXgsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZSxcbiAgICAgIGF0dHJzLFxuICAgICAgY2VsbEVkaXQsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIHNlbGVjdFJvdyxcbiAgICAgIHNlbGVjdGFibGUsXG4gICAgICBlZGl0YWJsZTogZWRpdGFibGVSb3dcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHtcbiAgICAgIG1vZGUsXG4gICAgICBvblN0YXJ0LFxuICAgICAgRWRpdGluZ0NlbGwsXG4gICAgICByaWR4OiBlZGl0aW5nUm93SWR4LFxuICAgICAgY2lkeDogZWRpdGluZ0NvbElkeCxcbiAgICAgIENMSUNLX1RPX0NFTExfRURJVCxcbiAgICAgIERCQ0xJQ0tfVE9fQ0VMTF9FRElULFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBjZWxsRWRpdDtcblxuICAgIGNvbnN0IGtleSA9IF8uZ2V0KHJvdywga2V5RmllbGQpO1xuICAgIGNvbnN0IHsgaGlkZVNlbGVjdENvbHVtbiB9ID0gc2VsZWN0Um93O1xuICAgIGNvbnN0IHRyQXR0cnMgPSB0aGlzLmRlbGVnYXRlKGF0dHJzKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8dHIgc3R5bGU9eyBzdHlsZSB9IGNsYXNzTmFtZT17IGNsYXNzTmFtZSB9IHsgLi4udHJBdHRycyB9PlxuICAgICAgICB7XG4gICAgICAgICAgKHNlbGVjdFJvdy5tb2RlICE9PSBDb25zdC5ST1dfU0VMRUNUX0RJU0FCTEVEICYmICFoaWRlU2VsZWN0Q29sdW1uKVxuICAgICAgICAgICAgPyAoXG4gICAgICAgICAgICAgIDxTZWxlY3Rpb25DZWxsXG4gICAgICAgICAgICAgICAgeyAuLi5zZWxlY3RSb3cgfVxuICAgICAgICAgICAgICAgIHJvd0tleT17IGtleSB9XG4gICAgICAgICAgICAgICAgcm93SW5kZXg9eyByb3dJbmRleCB9XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ9eyBzZWxlY3RlZCB9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyAhc2VsZWN0YWJsZSB9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApXG4gICAgICAgICAgICA6IG51bGxcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgY29sdW1ucy5tYXAoKGNvbHVtbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICghY29sdW1uLmhpZGRlbikge1xuICAgICAgICAgICAgICBjb25zdCB7IGRhdGFGaWVsZCB9ID0gY29sdW1uO1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gXy5nZXQocm93LCBkYXRhRmllbGQpO1xuICAgICAgICAgICAgICBsZXQgZWRpdGFibGUgPSBfLmlzRGVmaW5lZChjb2x1bW4uZWRpdGFibGUpID8gY29sdW1uLmVkaXRhYmxlIDogdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGRhdGFGaWVsZCA9PT0ga2V5RmllbGQgfHwgIWVkaXRhYmxlUm93KSBlZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbHVtbi5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICBlZGl0YWJsZSA9IGNvbHVtbi5lZGl0YWJsZShjb250ZW50LCByb3csIHJvd0luZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJvd0luZGV4ID09PSBlZGl0aW5nUm93SWR4ICYmIGluZGV4ID09PSBlZGl0aW5nQ29sSWR4KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVkaXRDZWxsc3R5bGUgPSBjb2x1bW4uZWRpdENlbGxTdHlsZSB8fCB7fTtcbiAgICAgICAgICAgICAgICBsZXQgZWRpdENlbGxjbGFzc2VzID0gY29sdW1uLmVkaXRDZWxsQ2xhc3NlcztcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbHVtbi5lZGl0Q2VsbFN0eWxlKSkge1xuICAgICAgICAgICAgICAgICAgZWRpdENlbGxzdHlsZSA9IGNvbHVtbi5lZGl0Q2VsbFN0eWxlKGNvbnRlbnQsIHJvdywgcm93SW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb2x1bW4uZWRpdENlbGxDbGFzc2VzKSkge1xuICAgICAgICAgICAgICAgICAgZWRpdENlbGxjbGFzc2VzID0gY29sdW1uLmVkaXRDZWxsQ2xhc3Nlcyhjb250ZW50LCByb3csIHJvd0luZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICA8RWRpdGluZ0NlbGxcbiAgICAgICAgICAgICAgICAgICAga2V5PXsgYCR7Y29udGVudH0tJHtpbmRleH1gIH1cbiAgICAgICAgICAgICAgICAgICAgcm93PXsgcm93IH1cbiAgICAgICAgICAgICAgICAgICAgcm93SW5kZXg9eyByb3dJbmRleCB9XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbj17IGNvbHVtbiB9XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4PXsgaW5kZXggfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9eyBlZGl0Q2VsbGNsYXNzZXMgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17IGVkaXRDZWxsc3R5bGUgfVxuICAgICAgICAgICAgICAgICAgICB7IC4uLnJlc3QgfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPENlbGxcbiAgICAgICAgICAgICAgICAgIGtleT17IGAke2NvbnRlbnR9LSR7aW5kZXh9YCB9XG4gICAgICAgICAgICAgICAgICByb3c9eyByb3cgfVxuICAgICAgICAgICAgICAgICAgcm93SW5kZXg9eyByb3dJbmRleCB9XG4gICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleD17IGluZGV4IH1cbiAgICAgICAgICAgICAgICAgIGNvbHVtbj17IGNvbHVtbiB9XG4gICAgICAgICAgICAgICAgICBvblN0YXJ0PXsgb25TdGFydCB9XG4gICAgICAgICAgICAgICAgICBlZGl0YWJsZT17IGVkaXRhYmxlIH1cbiAgICAgICAgICAgICAgICAgIGNsaWNrVG9FZGl0PXsgbW9kZSA9PT0gQ0xJQ0tfVE9fQ0VMTF9FRElUIH1cbiAgICAgICAgICAgICAgICAgIGRiY2xpY2tUb0VkaXQ9eyBtb2RlID09PSBEQkNMSUNLX1RPX0NFTExfRURJVCB9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICA8L3RyPlxuICAgICk7XG4gIH1cbn1cblxuUm93LnByb3BUeXBlcyA9IHtcbiAgcm93OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIHJvd0luZGV4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBhdHRyczogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuUm93LmRlZmF1bHRQcm9wcyA9IHtcbiAgZWRpdGFibGU6IHRydWUsXG4gIHN0eWxlOiB7fSxcbiAgY2xhc3NOYW1lOiBudWxsLFxuICBhdHRyczoge31cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFJvdztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy5qcyIsIi8qIGVzbGludCByZWFjdC9wcm9wLXR5cGVzOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IF8gZnJvbSAnLi91dGlscyc7XG5cbmNsYXNzIENlbGwgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLmhhbmRsZUVkaXRpbmdDZWxsID0gdGhpcy5oYW5kbGVFZGl0aW5nQ2VsbC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgaGFuZGxlRWRpdGluZ0NlbGwoZSkge1xuICAgIGNvbnN0IHsgY29sdW1uLCBvblN0YXJ0LCByb3dJbmRleCwgY29sdW1uSW5kZXgsIGNsaWNrVG9FZGl0LCBkYmNsaWNrVG9FZGl0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZXZlbnRzIH0gPSBjb2x1bW47XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgaWYgKGNsaWNrVG9FZGl0KSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbUNsaWNrID0gZXZlbnRzLm9uQ2xpY2s7XG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY3VzdG9tQ2xpY2spKSBjdXN0b21DbGljayhlKTtcbiAgICAgIH0gZWxzZSBpZiAoZGJjbGlja1RvRWRpdCkge1xuICAgICAgICBjb25zdCBjdXN0b21EYkNsaWNrID0gZXZlbnRzLm9uRG91YmxlQ2xpY2s7XG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY3VzdG9tRGJDbGljaykpIGN1c3RvbURiQ2xpY2soZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvblN0YXJ0KSB7XG4gICAgICBvblN0YXJ0KHJvd0luZGV4LCBjb2x1bW5JbmRleCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdyxcbiAgICAgIHJvd0luZGV4LFxuICAgICAgY29sdW1uLFxuICAgICAgY29sdW1uSW5kZXgsXG4gICAgICBlZGl0YWJsZSxcbiAgICAgIGNsaWNrVG9FZGl0LFxuICAgICAgZGJjbGlja1RvRWRpdFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFGaWVsZCxcbiAgICAgIGZvcm1hdHRlcixcbiAgICAgIGZvcm1hdEV4dHJhRGF0YSxcbiAgICAgIHN0eWxlLFxuICAgICAgY2xhc3NlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgZXZlbnRzLFxuICAgICAgYWxpZ24sXG4gICAgICBhdHRyc1xuICAgIH0gPSBjb2x1bW47XG4gICAgbGV0IGNlbGxUaXRsZTtcbiAgICBsZXQgY2VsbFN0eWxlID0ge307XG4gICAgbGV0IGNvbnRlbnQgPSBfLmdldChyb3csIGRhdGFGaWVsZCk7XG5cbiAgICBjb25zdCBjZWxsQXR0cnMgPSB7XG4gICAgICAuLi5fLmlzRnVuY3Rpb24oYXR0cnMpID8gYXR0cnMoY29udGVudCwgcm93LCByb3dJbmRleCwgY29sdW1uSW5kZXgpIDogYXR0cnMsXG4gICAgICAuLi5ldmVudHNcbiAgICB9O1xuXG4gICAgY29uc3QgY2VsbENsYXNzZXMgPSBfLmlzRnVuY3Rpb24oY2xhc3NlcylcbiAgICAgID8gY2xhc3Nlcyhjb250ZW50LCByb3csIHJvd0luZGV4LCBjb2x1bW5JbmRleClcbiAgICAgIDogY2xhc3NlcztcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgY2VsbFN0eWxlID0gXy5pc0Z1bmN0aW9uKHN0eWxlKSA/IHN0eWxlKGNvbnRlbnQsIHJvdywgcm93SW5kZXgsIGNvbHVtbkluZGV4KSA6IHN0eWxlO1xuICAgIH1cblxuICAgIGlmICh0aXRsZSkge1xuICAgICAgY2VsbFRpdGxlID0gXy5pc0Z1bmN0aW9uKHRpdGxlKSA/IHRpdGxlKGNvbnRlbnQsIHJvdywgcm93SW5kZXgsIGNvbHVtbkluZGV4KSA6IGNvbnRlbnQ7XG4gICAgICBjZWxsQXR0cnMudGl0bGUgPSBjZWxsVGl0bGU7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgY29udGVudCA9IGNvbHVtbi5mb3JtYXR0ZXIoY29udGVudCwgcm93LCByb3dJbmRleCwgZm9ybWF0RXh0cmFEYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoYWxpZ24pIHtcbiAgICAgIGNlbGxTdHlsZS50ZXh0QWxpZ24gPVxuICAgICAgICBfLmlzRnVuY3Rpb24oYWxpZ24pID8gYWxpZ24oY29udGVudCwgcm93LCByb3dJbmRleCwgY29sdW1uSW5kZXgpIDogYWxpZ247XG4gICAgfVxuXG4gICAgaWYgKGNlbGxDbGFzc2VzKSBjZWxsQXR0cnMuY2xhc3NOYW1lID0gY2VsbENsYXNzZXM7XG5cbiAgICBpZiAoIV8uaXNFbXB0eU9iamVjdChjZWxsU3R5bGUpKSBjZWxsQXR0cnMuc3R5bGUgPSBjZWxsU3R5bGU7XG4gICAgaWYgKGNsaWNrVG9FZGl0ICYmIGVkaXRhYmxlKSB7XG4gICAgICBjZWxsQXR0cnMub25DbGljayA9IHRoaXMuaGFuZGxlRWRpdGluZ0NlbGw7XG4gICAgfSBlbHNlIGlmIChkYmNsaWNrVG9FZGl0ICYmIGVkaXRhYmxlKSB7XG4gICAgICBjZWxsQXR0cnMub25Eb3VibGVDbGljayA9IHRoaXMuaGFuZGxlRWRpdGluZ0NlbGw7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8dGQgeyAuLi5jZWxsQXR0cnMgfT57IGNvbnRlbnQgfTwvdGQ+XG4gICAgKTtcbiAgfVxufVxuXG5DZWxsLnByb3BUeXBlcyA9IHtcbiAgcm93OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIHJvd0luZGV4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNvbHVtbjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBjb2x1bW5JbmRleDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBDZWxsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY2VsbC5qcyIsIi8qIGVzbGludFxuICByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDBcbiAganN4LWExMXkvbm8tbm9uaW50ZXJhY3RpdmUtZWxlbWVudC1pbnRlcmFjdGlvbnM6IDBcbiovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDb25zdCBmcm9tICcuLi9jb25zdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdGlvbkNlbGwgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIG1vZGU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICByb3dLZXk6IFByb3BUeXBlcy5hbnksXG4gICAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIG9uUm93U2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgcm93SW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgY2xpY2tUb1NlbGVjdDogUHJvcFR5cGVzLmJvb2xcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5oYW5kbGVDbGljayA9IHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICBjb25zdCB7IHNlbGVjdGVkIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIG5leHRQcm9wcy5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQ7XG4gIH1cblxuICBoYW5kbGVDbGljayhlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbW9kZTogaW5wdXRUeXBlLFxuICAgICAgcm93S2V5LFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICBvblJvd1NlbGVjdCxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgcm93SW5kZXgsXG4gICAgICBjbGlja1RvU2VsZWN0XG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZiAoY2xpY2tUb1NlbGVjdCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2hlY2tlZCA9IGlucHV0VHlwZSA9PT0gQ29uc3QuUk9XX1NFTEVDVF9TSU5HTEVcbiAgICAgID8gdHJ1ZVxuICAgICAgOiAhc2VsZWN0ZWQ7XG5cbiAgICBvblJvd1NlbGVjdChyb3dLZXksIGNoZWNrZWQsIHJvd0luZGV4LCBlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBtb2RlOiBpbnB1dFR5cGUsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIGRpc2FibGVkXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRkIG9uQ2xpY2s9eyB0aGlzLmhhbmRsZUNsaWNrIH0+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9eyBpbnB1dFR5cGUgfVxuICAgICAgICAgIGNoZWNrZWQ9eyBzZWxlY3RlZCB9XG4gICAgICAgICAgZGlzYWJsZWQ9eyBkaXNhYmxlZCB9XG4gICAgICAgIC8+XG4gICAgICA8L3RkPlxuICAgICk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1zZWxlY3Rpb24vc2VsZWN0aW9uLWNlbGwuanMiLCJpbXBvcnQgXyBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgZXZlbnRzID0gW1xuICAnb25DbGljaycsXG4gICdvbk1vdXNlRW50ZXInLFxuICAnb25Nb3VzZUxlYXZlJ1xuXTtcblxuZXhwb3J0IGRlZmF1bHQgRXh0ZW5kQmFzZSA9PlxuICBjbGFzcyBSb3dFdmVudERlbGVnYXRlciBleHRlbmRzIEV4dGVuZEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLmNsaWNrTnVtID0gMDtcbiAgICAgIHRoaXMuY3JlYXRlRGVmYXVsdEV2ZW50SGFuZGxlciA9IHRoaXMuY3JlYXRlRGVmYXVsdEV2ZW50SGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5jcmVhdGVDbGlja0V2ZW50SGFuZGxlciA9IHRoaXMuY3JlYXRlQ2xpY2tFdmVudEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjcmVhdGVEZWZhdWx0RXZlbnRIYW5kbGVyKGNiKSB7XG4gICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyByb3csIHJvd0luZGV4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjYihlLCByb3csIHJvd0luZGV4KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xpY2tFdmVudEhhbmRsZXIoY2IpIHtcbiAgICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcm93LFxuICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgIGtleUZpZWxkLFxuICAgICAgICAgIHNlbGVjdGFibGUsXG4gICAgICAgICAgcm93SW5kZXgsXG4gICAgICAgICAgc2VsZWN0Um93OiB7XG4gICAgICAgICAgICBvblJvd1NlbGVjdCxcbiAgICAgICAgICAgIGNsaWNrVG9FZGl0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjZWxsRWRpdDoge1xuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIERCQ0xJQ0tfVE9fQ0VMTF9FRElULFxuICAgICAgICAgICAgREVMQVlfRk9SX0RCQ0xJQ0tcbiAgICAgICAgICB9XG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNvbnN0IGNsaWNrRm4gPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYihlLCByb3csIHJvd0luZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IF8uZ2V0KHJvdywga2V5RmllbGQpO1xuICAgICAgICAgICAgb25Sb3dTZWxlY3Qoa2V5LCAhc2VsZWN0ZWQsIHJvd0luZGV4LCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1vZGUgPT09IERCQ0xJQ0tfVE9fQ0VMTF9FRElUICYmIGNsaWNrVG9FZGl0KSB7XG4gICAgICAgICAgdGhpcy5jbGlja051bSArPSAxO1xuICAgICAgICAgIF8uZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpY2tOdW0gPT09IDEpIHtcbiAgICAgICAgICAgICAgY2xpY2tGbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGlja051bSA9IDA7XG4gICAgICAgICAgfSwgREVMQVlfRk9SX0RCQ0xJQ0spKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpY2tGbigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlbGVnYXRlKGF0dHJzID0ge30pIHtcbiAgICAgIGNvbnN0IG5ld0F0dHJzID0ge307XG4gICAgICBpZiAodGhpcy5wcm9wcy5zZWxlY3RSb3cgJiYgdGhpcy5wcm9wcy5zZWxlY3RSb3cuY2xpY2tUb1NlbGVjdCkge1xuICAgICAgICBuZXdBdHRycy5vbkNsaWNrID0gdGhpcy5jcmVhdGVDbGlja0V2ZW50SGFuZGxlcihhdHRycy5vbkNsaWNrKTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgIGlmICghbmV3QXR0cnNbYXR0cl0pIHtcbiAgICAgICAgICBpZiAoZXZlbnRzLmluY2x1ZGVzKGF0dHIpKSB7XG4gICAgICAgICAgICBuZXdBdHRyc1thdHRyXSA9IHRoaXMuY3JlYXRlRGVmYXVsdEV2ZW50SGFuZGxlcihhdHRyc1thdHRyXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0F0dHJzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXdBdHRycztcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctZXZlbnQtZGVsZWdhdGVyLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNvbnN0IFJvd1NlY3Rpb24gPSAoeyBjb250ZW50LCBjb2xTcGFuIH0pID0+IChcbiAgPHRyPlxuICAgIDx0ZFxuICAgICAgZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXG4gICAgICBjb2xTcGFuPXsgY29sU3BhbiB9XG4gICAgICBjbGFzc05hbWU9XCJyZWFjdC1icy10YWJsZS1uby1kYXRhXCJcbiAgICA+XG4gICAgICB7IGNvbnRlbnQgfVxuICAgIDwvdGQ+XG4gIDwvdHI+XG4pO1xuXG5Sb3dTZWN0aW9uLnByb3BUeXBlcyA9IHtcbiAgY29udGVudDogUHJvcFR5cGVzLmFueSxcbiAgY29sU3BhbjogUHJvcFR5cGVzLm51bWJlclxufTtcblxuUm93U2VjdGlvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGNvbnRlbnQ6IG51bGwsXG4gIGNvbFNwYW46IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFJvd1NlY3Rpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctc2VjdGlvbi5qcyIsImltcG9ydCBDb2x1bW5SZXNvbHZlciBmcm9tICcuL2NvbHVtbi1yZXNvbHZlcic7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuaW1wb3J0IF8gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbmRCYXNlID0+XG4gIGNsYXNzIFRhYmxlUmVzb2x2ZXIgZXh0ZW5kcyBDb2x1bW5SZXNvbHZlcihFeHRlbmRCYXNlKSB7XG4gICAgdmFsaWRhdGVQcm9wcygpIHtcbiAgICAgIGNvbnN0IHsga2V5RmllbGQgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIWtleUZpZWxkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHNwZWNpZnkgYSBmaWVsZCBhcyBrZXkgdmlhIGtleUZpZWxkJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy52aXNpYmxlQ29sdW1uU2l6ZShmYWxzZSkgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZpc2libGUgY29sdW1ucyBkZXRlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5kYXRhLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9wcyByZXNvbHZlciBmb3IgY2VsbCBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGFkZHRpb25hbCBvcHRpb25zIGxpa2UgY2FsbGJhY2sgd2hpY2ggYXJlIGFib3V0IHRvIG1lcmdlIGludG8gcHJvcHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlc3VsdCAtIHByb3BzIGZvciBjZWxsIHNlbGVjdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHQubW9kZSAtIGlucHV0IHR5cGUgb2Ygcm93IHNlbGVjdGlvbiBvciBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICByZXNvbHZlU2VsZWN0Um93UHJvcHMob3B0aW9ucykge1xuICAgICAgY29uc3QgeyBzZWxlY3RSb3cgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IFJPV19TRUxFQ1RfRElTQUJMRUQgfSA9IENvbnN0O1xuXG4gICAgICBpZiAoXy5pc0RlZmluZWQoc2VsZWN0Um93KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnNlbGVjdFJvdyxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGU6IFJPV19TRUxFQ1RfRElTQUJMRURcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJvcHMgcmVzb2x2ZXIgZm9yIGhlYWRlciBjZWxsIHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYWRkdGlvbmFsIG9wdGlvbnMgbGlrZSBjYWxsYmFjayB3aGljaCBhcmUgYWJvdXQgdG8gbWVyZ2UgaW50byBwcm9wc1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gcmVzdWx0IC0gcHJvcHMgZm9yIGNlbGwgc2VsZWN0aW9uc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdC5tb2RlIC0gaW5wdXQgdHlwZSBvZiByb3cgc2VsZWN0aW9uIG9yIGRpc2FibGVkLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdC5jaGVja2VkU3RhdHVzIC0gY2hlY2tib3ggc3RhdHVzIGRlcGVuZGluZyBvbiBzZWxlY3RlZCByb3dzIGNvdW50c1xuICAgICAqL1xuICAgIHJlc29sdmVTZWxlY3RSb3dQcm9wc0ZvckhlYWRlcihvcHRpb25zID0ge30pIHtcbiAgICAgIGNvbnN0IHsgc2VsZWN0Um93IH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgeyBhbGxSb3dzU2VsZWN0ZWQsIHNlbGVjdGVkID0gW10sIC4uLnJlc3QgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIFJPV19TRUxFQ1RfRElTQUJMRUQsIENIRUNLQk9YX1NUQVRVU19DSEVDS0VELFxuICAgICAgICBDSEVDS0JPWF9TVEFUVVNfSU5ERVRFUk1JTkFURSwgQ0hFQ0tCT1hfU1RBVFVTX1VOQ0hFQ0tFRFxuICAgICAgfSA9IENvbnN0O1xuXG4gICAgICBpZiAoXy5pc0RlZmluZWQoc2VsZWN0Um93KSkge1xuICAgICAgICBsZXQgY2hlY2tlZFN0YXR1cztcblxuICAgICAgICAvLyBjaGVja2JveCBzdGF0dXMgZGVwZW5kaW5nIG9uIHNlbGVjdGVkIHJvd3MgY291bnRzXG4gICAgICAgIGlmIChhbGxSb3dzU2VsZWN0ZWQpIGNoZWNrZWRTdGF0dXMgPSBDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRDtcbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWQubGVuZ3RoID09PSAwKSBjaGVja2VkU3RhdHVzID0gQ0hFQ0tCT1hfU1RBVFVTX1VOQ0hFQ0tFRDtcbiAgICAgICAgZWxzZSBjaGVja2VkU3RhdHVzID0gQ0hFQ0tCT1hfU1RBVFVTX0lOREVURVJNSU5BVEU7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zZWxlY3RSb3csXG4gICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICBjaGVja2VkU3RhdHVzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGU6IFJPV19TRUxFQ1RfRElTQUJMRURcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcHJvcHMtcmVzb2x2ZXIvaW5kZXguanMiLCJleHBvcnQgZGVmYXVsdCBFeHRlbmRCYXNlID0+XG4gIGNsYXNzIENvbHVtblJlc29sdmVyIGV4dGVuZHMgRXh0ZW5kQmFzZSB7XG4gICAgdmlzaWJsZUNvbHVtblNpemUoaW5jbHVkZVNlbGVjdENvbHVtbiA9IHRydWUpIHtcbiAgICAgIGNvbnN0IGNvbHVtbkxlbiA9IHRoaXMucHJvcHMuY29sdW1ucy5maWx0ZXIoYyA9PiAhYy5oaWRkZW4pLmxlbmd0aDtcbiAgICAgIGlmICghaW5jbHVkZVNlbGVjdENvbHVtbikgcmV0dXJuIGNvbHVtbkxlbjtcbiAgICAgIGlmICh0aGlzLnByb3BzLnNlbGVjdFJvdyAmJiAhdGhpcy5wcm9wcy5zZWxlY3RSb3cuaGlkZVNlbGVjdENvbHVtbikge1xuICAgICAgICByZXR1cm4gY29sdW1uTGVuICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW5MZW47XG4gICAgfVxuICB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcHJvcHMtcmVzb2x2ZXIvY29sdW1uLXJlc29sdmVyLmpzIiwiLyogZXNsaW50IG5vLXJldHVybi1hc3NpZ246IDAgKi9cbi8qIGVzbGludCByZWFjdC9wcm9wLXR5cGVzOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFN0b3JlIGZyb20gJy4vc3RvcmUnO1xuaW1wb3J0IHdpdGhTb3J0IGZyb20gJy4vc29ydC93cmFwcGVyJztcbmltcG9ydCB3aXRoU2VsZWN0aW9uIGZyb20gJy4vcm93LXNlbGVjdGlvbi93cmFwcGVyJztcblxuaW1wb3J0IHJlbW90ZVJlc29sdmVyIGZyb20gJy4vcHJvcHMtcmVzb2x2ZXIvcmVtb3RlLXJlc29sdmVyJztcbmltcG9ydCBfIGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCB3aXRoRGF0YVN0b3JlID0gQmFzZSA9PlxuICBjbGFzcyBCb290c3RyYXBUYWJsZUNvbnRhaW5lciBleHRlbmRzIHJlbW90ZVJlc29sdmVyKENvbXBvbmVudCkge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLnN0b3JlID0gbmV3IFN0b3JlKHByb3BzLmtleUZpZWxkKTtcbiAgICAgIHRoaXMuc3RvcmUuZGF0YSA9IHByb3BzLmRhdGE7XG4gICAgICB0aGlzLndyYXBDb21wb25lbnRzKCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHRoaXMuc3RvcmUuc2V0QWxsRGF0YShuZXh0UHJvcHMuZGF0YSk7XG4gICAgfVxuXG4gICAgd3JhcENvbXBvbmVudHMoKSB7XG4gICAgICB0aGlzLkJhc2VDb21wb25lbnQgPSBCYXNlO1xuICAgICAgY29uc3QgeyBwYWdpbmF0aW9uLCBjb2x1bW5zLCBmaWx0ZXIsIHNlbGVjdFJvdywgY2VsbEVkaXQgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAocGFnaW5hdGlvbikge1xuICAgICAgICBjb25zdCB7IHdyYXBwZXJGYWN0b3J5IH0gPSBwYWdpbmF0aW9uO1xuICAgICAgICB0aGlzLkJhc2VDb21wb25lbnQgPSB3cmFwcGVyRmFjdG9yeSh0aGlzLkJhc2VDb21wb25lbnQsIHtcbiAgICAgICAgICByZW1vdGVSZXNvbHZlclxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbHVtbnMuZmlsdGVyKGNvbCA9PiBjb2wuc29ydCkubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLkJhc2VDb21wb25lbnQgPSB3aXRoU29ydCh0aGlzLkJhc2VDb21wb25lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgIGNvbnN0IHsgd3JhcHBlckZhY3RvcnkgfSA9IGZpbHRlcjtcbiAgICAgICAgdGhpcy5CYXNlQ29tcG9uZW50ID0gd3JhcHBlckZhY3RvcnkodGhpcy5CYXNlQ29tcG9uZW50LCB7XG4gICAgICAgICAgXyxcbiAgICAgICAgICByZW1vdGVSZXNvbHZlclxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNlbGxFZGl0KSB7XG4gICAgICAgIGNvbnN0IHsgd3JhcHBlckZhY3RvcnkgfSA9IGNlbGxFZGl0O1xuICAgICAgICB0aGlzLkJhc2VDb21wb25lbnQgPSB3cmFwcGVyRmFjdG9yeSh0aGlzLkJhc2VDb21wb25lbnQsIHtcbiAgICAgICAgICBfLFxuICAgICAgICAgIHJlbW90ZVJlc29sdmVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0Um93KSB7XG4gICAgICAgIHRoaXMuQmFzZUNvbXBvbmVudCA9IHdpdGhTZWxlY3Rpb24odGhpcy5CYXNlQ29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICBjb25zdCBiYXNlUHJvcHMgPSB7XG4gICAgICAgIC4uLnRoaXMucHJvcHMsXG4gICAgICAgIHN0b3JlOiB0aGlzLnN0b3JlXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8dGhpcy5CYXNlQ29tcG9uZW50IHsgLi4uYmFzZVByb3BzIH0gLz5cbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoRGF0YVN0b3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY29udGFpbmVyLmpzIiwiLyogZXNsaW50IG5vLXVuZGVyc2NvcmUtZGFuZ2xlOiAwICovXG5pbXBvcnQgXyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBzb3J0LCBuZXh0T3JkZXIgfSBmcm9tICcuL3NvcnQnO1xuaW1wb3J0IHsgZ2V0Um93QnlSb3dJZCB9IGZyb20gJy4vcm93cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JlIHtcbiAgY29uc3RydWN0b3Ioa2V5RmllbGQpIHtcbiAgICB0aGlzLl9kYXRhID0gW107XG4gICAgdGhpcy5fZmlsdGVyZWREYXRhID0gW107XG4gICAgdGhpcy5fa2V5RmllbGQgPSBrZXlGaWVsZDtcbiAgICB0aGlzLl9zb3J0T3JkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc29ydEZpZWxkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NlbGVjdGVkID0gW107XG4gICAgdGhpcy5fZmlsdGVycyA9IHt9O1xuICAgIHRoaXMuX3BhZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZVBlclBhZ2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBlZGl0KHJvd0lkLCBkYXRhRmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgY29uc3Qgcm93ID0gZ2V0Um93QnlSb3dJZCh0aGlzKShyb3dJZCk7XG4gICAgaWYgKHJvdykgXy5zZXQocm93LCBkYXRhRmllbGQsIG5ld1ZhbHVlKTtcbiAgfVxuXG4gIHNldFNvcnQoeyBkYXRhRmllbGQgfSwgb3JkZXIsIGRlZmF1bHRPcmRlcikge1xuICAgIHRoaXMuc29ydE9yZGVyID0gbmV4dE9yZGVyKHRoaXMpKGRhdGFGaWVsZCwgb3JkZXIsIGRlZmF1bHRPcmRlcik7XG4gICAgdGhpcy5zb3J0RmllbGQgPSBkYXRhRmllbGQ7XG4gIH1cblxuICBzb3J0QnkoeyBzb3J0RnVuYyB9KSB7XG4gICAgdGhpcy5kYXRhID0gc29ydCh0aGlzKShzb3J0RnVuYyk7XG4gIH1cblxuICBnZXRBbGxEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG5cbiAgc2V0QWxsRGF0YShkYXRhKSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgZGF0YSgpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fZmlsdGVycykubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9maWx0ZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9maWx0ZXJlZERhdGEgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gKGRhdGEgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKSA6IFtdKTtcbiAgICB9XG4gIH1cblxuICBnZXQgZmlsdGVyZWREYXRhKCkgeyByZXR1cm4gdGhpcy5fZmlsdGVyZWREYXRhOyB9XG4gIHNldCBmaWx0ZXJlZERhdGEoZmlsdGVyZWREYXRhKSB7IHRoaXMuX2ZpbHRlcmVkRGF0YSA9IGZpbHRlcmVkRGF0YTsgfVxuXG4gIGdldCBrZXlGaWVsZCgpIHsgcmV0dXJuIHRoaXMuX2tleUZpZWxkOyB9XG4gIHNldCBrZXlGaWVsZChrZXlGaWVsZCkgeyB0aGlzLl9rZXlGaWVsZCA9IGtleUZpZWxkOyB9XG5cbiAgZ2V0IHNvcnRPcmRlcigpIHsgcmV0dXJuIHRoaXMuX3NvcnRPcmRlcjsgfVxuICBzZXQgc29ydE9yZGVyKHNvcnRPcmRlcikgeyB0aGlzLl9zb3J0T3JkZXIgPSBzb3J0T3JkZXI7IH1cblxuICBnZXQgcGFnZSgpIHsgcmV0dXJuIHRoaXMuX3BhZ2U7IH1cbiAgc2V0IHBhZ2UocGFnZSkgeyB0aGlzLl9wYWdlID0gcGFnZTsgfVxuXG4gIGdldCBzaXplUGVyUGFnZSgpIHsgcmV0dXJuIHRoaXMuX3NpemVQZXJQYWdlOyB9XG4gIHNldCBzaXplUGVyUGFnZShzaXplUGVyUGFnZSkgeyB0aGlzLl9zaXplUGVyUGFnZSA9IHNpemVQZXJQYWdlOyB9XG5cbiAgZ2V0IHNvcnRGaWVsZCgpIHsgcmV0dXJuIHRoaXMuX3NvcnRGaWVsZDsgfVxuICBzZXQgc29ydEZpZWxkKHNvcnRGaWVsZCkgeyB0aGlzLl9zb3J0RmllbGQgPSBzb3J0RmllbGQ7IH1cblxuICBnZXQgc2VsZWN0ZWQoKSB7IHJldHVybiB0aGlzLl9zZWxlY3RlZDsgfVxuICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQpIHsgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDsgfVxuXG4gIGdldCBmaWx0ZXJzKCkgeyByZXR1cm4gdGhpcy5fZmlsdGVyczsgfVxuICBzZXQgZmlsdGVycyhmaWx0ZXJzKSB7IHRoaXMuX2ZpbHRlcnMgPSBmaWx0ZXJzOyB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9pbmRleC5qcyIsIi8qIGVzbGludCBuby1uZXN0ZWQtdGVybmFyeTogMCAqL1xuLyogZXNsaW50IG5vLWxvbmVseS1pZjogMCAqL1xuLyogZXNsaW50IG5vLXVuZGVyc2NvcmUtZGFuZ2xlOiAwICovXG5pbXBvcnQgXyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuXG5mdW5jdGlvbiBjb21wYXJhdG9yKGEsIGIpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IGIubG9jYWxlQ29tcGFyZShhKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBhID4gYiA/IC0xIDogKChhIDwgYikgPyAxIDogMCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGNvbnN0IHNvcnQgPSAoeyBkYXRhLCBzb3J0T3JkZXIsIHNvcnRGaWVsZCB9KSA9PiAoc29ydEZ1bmMpID0+IHtcbiAgY29uc3QgX2RhdGEgPSBbLi4uZGF0YV07XG4gIF9kYXRhLnNvcnQoKGEsIGIpID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCB2YWx1ZUEgPSBfLmdldChhLCBzb3J0RmllbGQpO1xuICAgIGxldCB2YWx1ZUIgPSBfLmdldChiLCBzb3J0RmllbGQpO1xuICAgIHZhbHVlQSA9IF8uaXNEZWZpbmVkKHZhbHVlQSkgPyB2YWx1ZUEgOiAnJztcbiAgICB2YWx1ZUIgPSBfLmlzRGVmaW5lZCh2YWx1ZUIpID8gdmFsdWVCIDogJyc7XG5cbiAgICBpZiAoc29ydEZ1bmMpIHtcbiAgICAgIHJlc3VsdCA9IHNvcnRGdW5jKHZhbHVlQSwgdmFsdWVCLCBzb3J0T3JkZXIsIHNvcnRGaWVsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzb3J0T3JkZXIgPT09IENvbnN0LlNPUlRfREVTQykge1xuICAgICAgICByZXN1bHQgPSBjb21wYXJhdG9yKHZhbHVlQSwgdmFsdWVCKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbXBhcmF0b3IodmFsdWVCLCB2YWx1ZUEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIF9kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IG5leHRPcmRlciA9IHN0b3JlID0+IChmaWVsZCwgb3JkZXIsIGRlZmF1bHRPcmRlciA9IENvbnN0LlNPUlRfREVTQykgPT4ge1xuICBpZiAob3JkZXIpIHJldHVybiBvcmRlcjtcblxuICBpZiAoZmllbGQgIT09IHN0b3JlLnNvcnRGaWVsZCkge1xuICAgIHJldHVybiBkZWZhdWx0T3JkZXI7XG4gIH1cbiAgcmV0dXJuIHN0b3JlLnNvcnRPcmRlciA9PT0gQ29uc3QuU09SVF9ERVNDID8gQ29uc3QuU09SVF9BU0MgOiBDb25zdC5TT1JUX0RFU0M7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvc29ydC5qcyIsIi8qIGVzbGludCByZWFjdC9wcm9wLXR5cGVzOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCByZW1vdGVSZXNvbHZlciBmcm9tICcuLi9wcm9wcy1yZXNvbHZlci9yZW1vdGUtcmVzb2x2ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlID0+XG4gIGNsYXNzIFNvcnRXcmFwcGVyIGV4dGVuZHMgcmVtb3RlUmVzb2x2ZXIoQ29tcG9uZW50KSB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgIHN0b3JlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5oYW5kbGVTb3J0ID0gdGhpcy5oYW5kbGVTb3J0LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgY29uc3QgeyBjb2x1bW5zLCBkZWZhdWx0U29ydGVkLCBkZWZhdWx0U29ydERpcmVjdGlvbiwgc3RvcmUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAvLyBkZWZhdWx0U29ydGVkIGlzIGFuIGFycmF5LCBpdCdzIHJlYWR5IHRvIHVzZSBhcyBtdWx0aSAvIHNpbmdsZSBzb3J0XG4gICAgICAvLyB3aGVuIHdlIHN0YXJ0IHRvIHN1cHBvcnQgbXVsdGkgc29ydCwgcGxlYXNlIHVwZGF0ZSBmb2xsb3dpbmcgY29kZSB0byB1c2UgYXJyYXkuZm9yRWFjaFxuICAgICAgaWYgKGRlZmF1bHRTb3J0ZWQgJiYgZGVmYXVsdFNvcnRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRhdGFGaWVsZCA9IGRlZmF1bHRTb3J0ZWRbMF0uZGF0YUZpZWxkO1xuICAgICAgICBjb25zdCBvcmRlciA9IGRlZmF1bHRTb3J0ZWRbMF0ub3JkZXI7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnMuZmlsdGVyKGNvbCA9PiBjb2wuZGF0YUZpZWxkID09PSBkYXRhRmllbGQpO1xuICAgICAgICBpZiAoY29sdW1uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdG9yZS5zZXRTb3J0KGNvbHVtblswXSwgb3JkZXIsIGRlZmF1bHRTb3J0RGlyZWN0aW9uKTtcblxuICAgICAgICAgIGlmIChjb2x1bW5bMF0ub25Tb3J0KSB7XG4gICAgICAgICAgICBjb2x1bW5bMF0ub25Tb3J0KHN0b3JlLnNvcnRGaWVsZCwgc3RvcmUuc29ydE9yZGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5pc1JlbW90ZVNvcnQoKSB8fCB0aGlzLmlzUmVtb3RlUGFnaW5hdGlvbigpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNvcnRDaGFuZ2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcmUuc29ydEJ5KGNvbHVtblswXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIGxldCBzb3J0ZWRDb2x1bW47XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRQcm9wcy5jb2x1bW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcHMuY29sdW1uc1tpXS5kYXRhRmllbGQgPT09IG5leHRQcm9wcy5zdG9yZS5zb3J0RmllbGQpIHtcbiAgICAgICAgICBzb3J0ZWRDb2x1bW4gPSBuZXh0UHJvcHMuY29sdW1uc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNvcnRlZENvbHVtbiAmJiBzb3J0ZWRDb2x1bW4uc29ydCkge1xuICAgICAgICBuZXh0UHJvcHMuc3RvcmUuc29ydEJ5KHNvcnRlZENvbHVtbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlU29ydChjb2x1bW4pIHtcbiAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRoaXMucHJvcHM7XG4gICAgICBzdG9yZS5zZXRTb3J0KGNvbHVtbiwgdW5kZWZpbmVkLCB0aGlzLnByb3BzLmRlZmF1bHRTb3J0RGlyZWN0aW9uKTtcblxuICAgICAgaWYgKGNvbHVtbi5vblNvcnQpIHtcbiAgICAgICAgY29sdW1uLm9uU29ydChzdG9yZS5zb3J0RmllbGQsIHN0b3JlLnNvcnRPcmRlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzUmVtb3RlU29ydCgpIHx8IHRoaXMuaXNSZW1vdGVQYWdpbmF0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTb3J0Q2hhbmdlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5zb3J0QnkoY29sdW1uKTtcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxCYXNlXG4gICAgICAgICAgeyAuLi50aGlzLnByb3BzIH1cbiAgICAgICAgICBvblNvcnQ9eyB0aGlzLmhhbmRsZVNvcnQgfVxuICAgICAgICAgIGRhdGE9eyB0aGlzLnByb3BzLnN0b3JlLmRhdGEgfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zb3J0L3dyYXBwZXIuanMiLCIvKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuaW1wb3J0IHtcbiAgaXNBbnlTZWxlY3RlZFJvdyxcbiAgc2VsZWN0YWJsZUtleXMsXG4gIHVuU2VsZWN0YWJsZUtleXMsXG4gIGdldFNlbGVjdGVkUm93c1xufSBmcm9tICcuLi9zdG9yZS9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgZ2V0Um93QnlSb3dJZCB9IGZyb20gJy4uL3N0b3JlL3Jvd3MnO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlID0+XG4gIGNsYXNzIFJvd1NlbGVjdGlvbldyYXBwZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICBzdG9yZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgICAgc2VsZWN0Um93OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5oYW5kbGVSb3dTZWxlY3QgPSB0aGlzLmhhbmRsZVJvd1NlbGVjdC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5oYW5kbGVBbGxSb3dzU2VsZWN0ID0gdGhpcy5oYW5kbGVBbGxSb3dzU2VsZWN0LmJpbmQodGhpcyk7XG5cbiAgICAgIHByb3BzLnN0b3JlLnNlbGVjdGVkID0gcHJvcHMuc2VsZWN0Um93LnNlbGVjdGVkIHx8IFtdO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc2VsZWN0ZWRSb3dLZXlzOiBwcm9wcy5zdG9yZS5zZWxlY3RlZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgbmV4dFByb3BzLnN0b3JlLnNlbGVjdGVkID0gbmV4dFByb3BzLnNlbGVjdFJvdy5zZWxlY3RlZCB8fCBbXTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtcbiAgICAgICAgc2VsZWN0ZWRSb3dLZXlzOiBuZXh0UHJvcHMuc3RvcmUuc2VsZWN0ZWRcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByb3cgc2VsZWN0aW9uIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm93S2V5IC0gcm93IGtleSBvZiB3aGF0IHdhcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrZWQgLSBuZXh0IGNoZWNrZWQgc3RhdHVzIG9mIGlucHV0IGJ1dHRvbi5cbiAgICAgKi9cbiAgICBoYW5kbGVSb3dTZWxlY3Qocm93S2V5LCBjaGVja2VkLCByb3dJbmRleCwgZSkge1xuICAgICAgY29uc3QgeyBzZWxlY3RSb3c6IHsgbW9kZSwgb25TZWxlY3QgfSwgc3RvcmUgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IFJPV19TRUxFQ1RfU0lOR0xFIH0gPSBDb25zdDtcblxuICAgICAgbGV0IGN1cnJTZWxlY3RlZCA9IFsuLi5zdG9yZS5zZWxlY3RlZF07XG5cbiAgICAgIGlmIChtb2RlID09PSBST1dfU0VMRUNUX1NJTkdMRSkgeyAvLyB3aGVuIHNlbGVjdCBtb2RlIGlzIHJhZGlvXG4gICAgICAgIGN1cnJTZWxlY3RlZCA9IFtyb3dLZXldO1xuICAgICAgfSBlbHNlIGlmIChjaGVja2VkKSB7IC8vIHdoZW4gc2VsZWN0IG1vZGUgaXMgY2hlY2tib3hcbiAgICAgICAgY3VyclNlbGVjdGVkLnB1c2gocm93S2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJTZWxlY3RlZCA9IGN1cnJTZWxlY3RlZC5maWx0ZXIodmFsdWUgPT4gdmFsdWUgIT09IHJvd0tleSk7XG4gICAgICB9XG5cbiAgICAgIHN0b3JlLnNlbGVjdGVkID0gY3VyclNlbGVjdGVkO1xuXG4gICAgICBpZiAob25TZWxlY3QpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gZ2V0Um93QnlSb3dJZChzdG9yZSkocm93S2V5KTtcbiAgICAgICAgb25TZWxlY3Qocm93LCBjaGVja2VkLCByb3dJbmRleCwgZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtcbiAgICAgICAgc2VsZWN0ZWRSb3dLZXlzOiBjdXJyU2VsZWN0ZWRcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgYWxsIHJvd3Mgc2VsZWN0aW9uIG9uIGhlYWRlciBjZWxsIGJ5IHN0b3JlLnNlbGVjdGVkXG4gICAgICovXG4gICAgaGFuZGxlQWxsUm93c1NlbGVjdChlKSB7XG4gICAgICBjb25zdCB7IHN0b3JlLCBzZWxlY3RSb3c6IHtcbiAgICAgICAgb25TZWxlY3RBbGwsXG4gICAgICAgIG5vblNlbGVjdGFibGVcbiAgICAgIH0gfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IGlzQW55U2VsZWN0ZWRSb3coc3RvcmUpKG5vblNlbGVjdGFibGUpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSAhc2VsZWN0ZWQ7XG5cbiAgICAgIGNvbnN0IGN1cnJTZWxlY3RlZCA9IHJlc3VsdCA/XG4gICAgICAgIHNlbGVjdGFibGVLZXlzKHN0b3JlKShub25TZWxlY3RhYmxlKSA6XG4gICAgICAgIHVuU2VsZWN0YWJsZUtleXMoc3RvcmUpKG5vblNlbGVjdGFibGUpO1xuXG5cbiAgICAgIHN0b3JlLnNlbGVjdGVkID0gY3VyclNlbGVjdGVkO1xuXG4gICAgICBpZiAob25TZWxlY3RBbGwpIHtcbiAgICAgICAgb25TZWxlY3RBbGwocmVzdWx0LCBnZXRTZWxlY3RlZFJvd3Moc3RvcmUpLCBlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoe1xuICAgICAgICBzZWxlY3RlZFJvd0tleXM6IGN1cnJTZWxlY3RlZFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxCYXNlXG4gICAgICAgICAgeyAuLi50aGlzLnByb3BzIH1cbiAgICAgICAgICBvblJvd1NlbGVjdD17IHRoaXMuaGFuZGxlUm93U2VsZWN0IH1cbiAgICAgICAgICBvbkFsbFJvd3NTZWxlY3Q9eyB0aGlzLmhhbmRsZUFsbFJvd3NTZWxlY3QgfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctc2VsZWN0aW9uL3dyYXBwZXIuanMiXSwic291cmNlUm9vdCI6IiJ9
//# sourceMappingURL=react-bootstrap-table-next.js.map